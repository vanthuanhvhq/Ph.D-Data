# -*- coding: utf-8 -*-
"""OptimizationProcess_of_FuzzyLogicController.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/17FUnDR7XNjMsDOFrXfnBNWffqXYntEjF

# Optimization of Fuzzy Logic Controller Used for a Differential Drive Wheeled Mobile Robot

This notebook contains a set of experiments with fuzzy logic controller optimization. The fuzzy logic controller is designed for robot control.
"""

_runDemos = True # this is queried in this document later multiple times

"""## Cluster Query

This task could use for its solution a computer cluster. As it is optional, use it only when you are running it. In this case you must set the option ```useCluster``` to ```True``` and set proper value in ```url``` variable.
"""

useCluster = False
url = 'http://192.168.1.100:4000/api/evaluator/FFFF'

Waypoint = True
Number8 = False
Circle = False

"""## Inevitable Imports

Fuzzy operations are computed with use of [scikit-fuzzy library](https://github.com/scikit-fuzzy/scikit-fuzzy).
"""

!pip install scikit-fuzzy

import numpy as np
import math
import random
from math import *
import scipy.integrate as integrate
import matplotlib.pyplot as plt
import pandas as pd
import skfuzzy as fuzz

# Commented out IPython magic to ensure Python compatibility.
# %matplotlib inline

"""With this %matplotlib inline, the output of plotting commands is displayed inline within frontends like the Jupyter notebook, directly below the code cell that produced it. The resulting plots will then also be stored in the notebook document.

## Robot parameters
"""

robotState0 = {
    'x': 0,
    'y': 0,
    'theta': 3.14 / 4
}

robotParams = {
    'r': 0.0925,
    'b': 0.37,
    'm': 9,
    'I': 0.16245,
}

"""## Robot models

### Kinematic model
"""

from math import sin, cos
def createRobot(params):
    m = params['m']
    I = params['I']

    def robot(t, currentState, controller):
        # ask controller for velocity and omega
        velocity, omega = controller(t, currentState)

        currentTheta = currentState[2]
        cosTheta = cos(currentTheta)
        sinTheta = sin(currentTheta)

        x_dot = velocity * cosTheta
        y_dot = velocity * sinTheta
        theta_dot = omega

        E = 0.5 * (m * velocity * velocity + I * omega * omega)

        return [x_dot, y_dot, theta_dot, velocity, omega, E] # velocity, omega, E are returned for easy evaluation they are not needed for computation
    return robot

robot = createRobot(robotParams)

"""### Dynamic Model

The dynamic model extends the kinematic model with differential equations describing the motors.
"""

# example of motor parameters,
motorParams = {
    'J': 0.01,
    'B': 0.1,
    
    'Kt': 0.01,
    'Ke': 0.01,
    'K': 0.01,
    
    'Ra': 0.1,
    'La': 0.01
}

#//////////////////////////////////////////////////////////////////////////////
def createFilter2ndOrder(b1, b0, a1, a0):
    def filter2ndOrder(t, u, currentState):
        x0 = currentState[0]
        x1 = currentState[1]
        dx0 = b0 * u + a0 * x0 + x1
        dx1 = b1 * u + a1 * x0
        return [dx0, dx1]
    return filter2ndOrder

def createMotorModel(motorParams=None):
    if motorParams is None:
        return None
    
    K = motorParams['K']
    J = motorParams['J']
    La = motorParams['La']
    Ra = motorParams['Ra']
    B = motorParams['B']
    
    b1 = K / (La * J)
    b0 = 0
    a1 = -(Ra * B + K * K) / (La * J)
    a0 = -(Ra * J + La * B) / (La * J)
    return createFilter2ndOrder(b1, b0, a1, a0)
    

def createRobotModelWithDynamic(params, motorModel = None):
    """
    function returns standard ODE model usable in many libraries (scipy)
    """
    # motorAsFilter = createFilter2ndOrder(b1, b0, a1, a0)
    m = params['m']
    I = params['I']
    b = params['b']

    motorAsFilter = motorModel
    def robotWithDynamic(t, currentState, controller):
        # ask controller for velocity and omega
        velocity, omega = controller(t, currentState)

        delta = omega * b / 2
        vL = velocity - delta
        vR = velocity + delta
        vLState = currentState[6:8]
        vRState = currentState[8:10]
        vLStateD = motorAsFilter(t, vL, vLState)
        vRStateD = motorAsFilter(t, vR, vRState)
        vLFiltered = vLState[0]
        vRFiltered = vRState[0]

        velocity = (vRFiltered + vLFiltered) / 2
        delta = (vRFiltered - vLFiltered) / 2
        omega = 2 * delta / b

        currentTheta = currentState[2]
        cosTheta = cos(currentTheta)
        sinTheta = sin(currentTheta)

        x_dot = velocity * cosTheta
        y_dot = velocity * sinTheta
        theta_dot = omega

        E = 0.5*(m*(velocity)*(velocity) + I*(omega)*(omega))

        return [x_dot, y_dot, theta_dot, velocity, omega, E, *vLStateD, *vRStateD] #velocity, omega, E are returned for easy evaluation they are not needed for computation

    def robot(t, currentState, controller):
        """
        This closure is result of parent function
        """
        # ask controller for velocity and omega
        velocity, omega = controller(t, currentState)

        currentTheta = currentState[2]
        cosTheta = cos(currentTheta)
        sinTheta = sin(currentTheta)

        x_dot = velocity * cosTheta
        y_dot = velocity * sinTheta
        theta_dot = omega

        E = 0.5 * (m * velocity * velocity + I * omega * omega)

        return [x_dot, y_dot, theta_dot, velocity, omega, E] #velocity, omega, E are returned for easy evaluation they are not needed for computation

    if motorModel is None:
        return robot
    else:
        return robotWithDynamic
    pass
  
motorModel = createMotorModel(motorParams)    
robotWithDynamic = createRobotModelWithDynamic(robotParams, motorModel)
robot = robotWithDynamic # If you delete / comment this line, only the Kinematic model is taken into account.

"""## Solver

### Selectors

Selectors are named functions which have been designed for selecting appropriate part of simulation results. They can simplify a data capture or a data analysis in or after simulation.
"""

# selectors are defined for extration of data from results computed by ODE solver
selectx = lambda item: item['y'][0]       # x position
selecty = lambda item: item['y'][1]       # y position
selectt = lambda item: item['time']       # time
selectv = lambda item: item['dy'][3]      # velocity
selectomega = lambda item: item['dy'][2]  # omega = theta_dot
selecte = lambda item: item['TotalEnergy']# total energy
selects = lambda item: item['y'][3]       # displacement
selectors = {
    'time': selectt,
    'x': selectx, 
    'y': selecty, 
    'd': selects, 
    'v': selectv, 
    'omega': selectomega,
    'E': selecte}

"""### Solver Function

The next function is designed as a generator and thus it performs one simulation step and returns a single simulation state when it is asked. Such design allows to have infinite loop inside this function. Theory about generators could be studied [here](https://wiki.python.org/moin/Generators).
"""

def compute(model, state0, t0 = 0.0, t_bound = 10, max_step = 0.05):
    """
    This function returns a generator containing the sequence of resuls. 
    In this particular case it will return a sequence of robot states.
    """
    solver = integrate.RK45(fun = model, t0 = t0, y0 = state0, t_bound = t_bound, max_step = max_step)
    cnt = 0
    lastEnergy = 0
    totalEnergy = 0

    while True:
        message = solver.step()
        currentItem = {'time': solver.t, 'y': solver.y, 'dy': model(solver.t, solver.y)}
        
        ###################################################
        # Energy calculation / energy sumation
        currentEnergy = currentItem['dy'][5] 
        deltaEnergy = currentEnergy - lastEnergy

        if deltaEnergy > 0:
            totalEnergy = totalEnergy + deltaEnergy
        lastEnergy = currentEnergy
        currentItem['TotalEnergy'] = totalEnergy
        ###################################################

        yield currentItem
        if (not(solver.status == 'running')):
            break
    return

"""## Path Controller

Path Controller transforms a controller navigating robot towards a fixed distance to the controller able switch the destination immediately after reaching point defined by a given path.
"""

def controllerForPath(controller, path, distanceEps=1e-2):
    destinationX, destinationY, destinationOrietation = next(path)
    destinationState = [destinationX, destinationY, destinationOrietation]
    lastReached = False
    #print('Destination set to', destinationState)
    def result(t, currentState):
        """
        This closure is result of parent function and acts as a controller - mediator,
        which commands the given controller.
        """
        nonlocal destinationX # use parent variable
        nonlocal destinationY # use parent variable
        nonlocal destinationState # use parent variable
        nonlocal lastReached # use parent variable

        currentX = currentState[0]
        currentY = currentState[1]
        deltaX = destinationX - currentX
        deltaY = destinationY - currentY
        if (lastReached == False):
          # last point in path was not reached
          if (deltaX * deltaX + deltaY * deltaY < distanceEps):
            # robot is close enought to currentDestination
            try:
                # try to get another point on path
                destinationX, destinationY, destinationOrietation = next(path)
                destinationState = [destinationX, destinationY, destinationOrietation]
                #print('Destination set to', destinationState, 'while in state', currentState)
            except StopIteration:
              # there are no other points
              lastReached = True
        if (lastReached):
            return (0, 0)
        else:
            return controller(t, currentState, destinationState)
    return result

"""## Model Creator

Model creator is function which packs all subsystems into one described by standard ODE function. Standard methods for ODE problems could be applied on such result / function. Standard use are granted by the signature
```python
def func(time, state)
```
Such signature has a function returned by ```robotModelCreator```.
"""

def robotModelCreator(controllerCreator, path, **kwargs):
    controller_ = controllerCreator(**kwargs)
    savedController = controllerForPath(controller_, path)
    def resultRMC(t, currentState):
        return robot(t, currentState, savedController)
    return resultRMC

"""## Computation

Simple compute allows to fully define parameters at first and then use it on model. Such approach is usefull in case when different models (controllers) are used for same task. In this case this function simplify comparison of different controllers.
"""

def simpleCompute(computefunc, state0, t0 = 0, t_bound = 200, max_step = 0.05):
    def resultSC(model):
        return computefunc(
          model, state0 = state0, t0 = t0, t_bound = t_bound, max_step = max_step)
    return resultSC

"""## Controllers

All controllers have to have same signature (parameter list)

```python
def controller(t, currentState, destinationState)
```

thus a creator taking special controller parameters must be defined. Such a creator should accept all special parameters and return controller with standard signature.

### Circle Controller

The Circle-based controller has been introduced and improved by Prof. Alexandr Štefek in [18] of this paper. (A. Stefek, V. Krivanek, Y. Bergeon, J. Motsch, “Differential Drive Robot: Spline-Based Design of Circular Path”. Awrejcewicz J. (eds) Dynamical Systems: Theoretical and Experimental Analysis. Springer Proceedings in Mathematics & Statistics, vol 182. Springer, Cham, 2016, pp 331-342.)

A brief of this controller as below:

$v=\frac{v_r+v_l}{2}$

$\Delta=\frac{v_r-v_l}{2}$

$R=\frac{v b}{2 \Delta}$

$\omega=\frac{2 \Delta}{b}$

$\dot x=v \cdot cos(\theta)$

$\dot y=v \cdot sin(\theta)$

$\dot \theta=\omega$

$\omega=-2\cdot k_1\cdot v\cdot \frac{\Delta X\cdot sin(\theta) - \Delta Y\cdot cos(\theta)}{(\Delta X)^2 + (\Delta Y)^2}$

Where:

 $k_1 > 0$ : is a coefficient of controller.
 For this simulation we use $v = v_{ri}$ is reference linear velocity of the robot
"""

def createCircleControllerWithGain(gain, omega_ri, vri, lowVelocityLimit, highVelocityLimit, lowOmegaLimit, highOmegaLimit):
    def controller(t, currentState, destinationState):
        currentX = currentState[0]
        currentY = currentState[1]
        currentTheta = currentState[2]

        destinationX = destinationState[0]
        destinationY = destinationState[1]

        cosTheta = cos(currentTheta)
        sinTheta = sin(currentTheta)

        deltaX = destinationX - currentX
        deltaY = destinationY - currentY

        velocity = vri
        omega = -2 * gain * vri * (deltaX * sinTheta - deltaY * cosTheta) / (deltaX * deltaX + deltaY * deltaY)
    
        if (velocity > highVelocityLimit):
            velocity = highVelocityLimit
        if (velocity < lowVelocityLimit):
            velocity = lowVelocityLimit
        if (omega > highOmegaLimit):
            omega = highOmegaLimit
        if (omega < lowOmegaLimit):
            omega = lowOmegaLimit

        return velocity, omega
    return controller

"""#### Full Example of Use

This part demonstrate the ide of code structure. There is the full run of simulation described by a set of functions.
"""

def localDemo():
    pathForSimulation = iter([
            [0, 0, 0],  #X, Y, orientation
            [10, 0, 0], #X, Y, orientation
            [10, 10, 0], #X, Y, orientation
            [0, 10, 0], #X, Y, orientation
            [0, 0, 0]
        ])

    robotState0 = {
            'x': 0,
            'y': 0,
            'theta': -3.14 / 4
        }

    t0 = 0
    t_bound = 100
    max_step = 0.05

    state0 = None
    if robot == robotWithDynamic:
        state0 = np.array([robotState0['x'], robotState0['y'], robotState0['theta'], 0, 0, 0, 0, 0, 0, 0]) # x0=0, y0=0, theta
    else:
        state0 = np.array([robotState0['x'], robotState0['y'], robotState0['theta'], 0, 0, 0]) # x0=0, y0=0,theta

    solverfunc = simpleCompute(
        compute, state0 = state0, 
        t0 = t0, t_bound = t_bound, max_step = max_step)    

    controllerParams = {
        'gain': 4, 
        'omega_ri': 0, 
        'vri': 2.0, 
        'lowVelocityLimit': 0.2, 
        'highVelocityLimit': 2.0, 
        'lowOmegaLimit': -0.75, 
        'highOmegaLimit': 0.75
        }

    fullRobot = robotModelCreator(createCircleControllerWithGain, pathForSimulation, **controllerParams)      
    state1 = fullRobot(0, state0)
    robotStates = solverfunc(fullRobot)

    results = {}
    for key, selector in selectors.items():
        print(key)
        results[key] = []

    for currentState in robotStates: # readout all states from current moving robot
        for key, selector in selectors.items():
            results[key].append(selector(currentState))

    plt.plot(results['x'], results['y'])

if _runDemos:
    localDemo()

"""### Robins

The Robins Mathew based controller has introduced by Robins Mathew in [28]. (R. Mathew and S. S. Hiremath, “Development of Waypoint Tracking Controller for Differential Drive Mobile Robot,” in International Conference on Control, Decision and Information Technologies (CoDIT), Paris, France, 2019, pp. 1121-1126.)

A brief of the Robins Mathew Controller is as below:


$$ \begin{pmatrix}
v_{ci} \\
\omega_{ci}  
\end{pmatrix} = 
\begin{pmatrix}
v_{ri}\cdot cos\theta_{ie}\\
\omega_{ri} + k_1\cdot v_{ri}\cdot T_{ie} + k_2\cdot v_{ri}\cdot sin\theta_{ie} 
\end{pmatrix} $$

Where:

$v_{ci}$ : is the linear velocity of robot

$\omega_{ci}$ : is the angular velocity of robot

$v_{ri}$ : is the reference linear velocity of robot

$\omega_{ri}$ : is the reference angular velocity of robot

$\theta_{ie}$ = $\theta_{wk} - \theta_i$ : 

$\tan\theta_{ie} = \frac{y_{wk}-y_i}{x_{wk}-x_i}$   

$\theta_i$ is the orientation of robot

$k_1, k_2 > 0$ : are the control gains

$T_{ie} = sin\phi\cdot(x_i - x_{wk}) - cos\phi\cdot(y_i - y_{wk})$ : is the cross-track error

$\tan\phi = \frac{y_{wk}-y_{wk-1}}{x_{wk}-x_{wk-1}}$ the $\phi$ is defined as the angle made by the line
connecting current waypoint with the previous waypoint

$(x_i, y_i, \theta_i)$ : is the current robot position

$(x_{wk}, y_{wk}, \theta_{wk})$ : is the waypoint posture
"""

def createController_By_RobinsMathew(k0, k1, omega_ri, vri, lowVelocityLimit, highVelocityLimit, lowOmegaLimit, highOmegaLimit):
    def controller(t, currentState, destinationState):
        currentX = currentState[0]
        currentY = currentState[1]
        currentTheta = currentState[2]

        destinationX = destinationState[0]
        destinationY = destinationState[1]

        cosTheta = cos(currentTheta)
        sinTheta = sin(currentTheta)
    
        deltaX = destinationX - currentX
        deltaY = destinationY - currentY
        theta_destination = atan2(deltaY, deltaX)
        theta_error = theta_destination - currentTheta

        Te = math.sin(theta_destination)*deltaX - math.cos(theta_destination)*deltaY
    
        velocity = vri*math.cos(theta_error)
        omega = omega_ri + k0*vri*Te + k1*vri*math.sin(theta_error)

        if velocity > highVelocityLimit:
            velocity = highVelocityLimit
        if (velocity < lowVelocityLimit):
            velocity = lowVelocityLimit
        if omega > highOmegaLimit:
            omega = highOmegaLimit
        if (omega < lowOmegaLimit):
            omega = lowOmegaLimit
      
        return velocity, omega
    return controller

"""###  Chaudhari-based Controller

Chaudhari et al. have used Dubins path to smooth the optimal path (A*)

Dubins curve consists of several circular segments and straight segments. The shortest Dubins curve consists of three circular segments and straight segments. The primary forms are: (RSL, LSL, RSR, LSR, RLR, LRL). Where L, R represent the circular turning to the left and right respectively, S represent the tangent connecting two turning circulars [16].

The Dubins Path-based controller is expressed as below:

`minimal_radius = radius` is minimal rotation radius of the robot

`angle_epsilon = 0.05` is small positive value of the angle 

$v_{ri}$ is linear reference velocity of the robot

` angle_delta = currentTheta - angle_to_destination`

- If `angle_delta < - angle_epsilon`, then controller is

> $v = v_{ri}$; 
$\omega = \frac {v}{radius}$

- If `angle_delta > + angle_epsilon`, then controller is

> $v = v_{ri}$; 
$\omega = \frac {-v}{radius}$

- If `angle_delta = angle_epsilon`, then controller is

> $v = v_{ri}$; 
$\omega = 0$
"""

def createChaudhariController(radius, omega_ri, vri, lowVelocityLimit, highVelocityLimit,lowOmegaLimit, highOmegaLimit):
  minimal_radius = radius
  angle_epsilon = 0.05 # radians
  def controller(t, currentState, destinationState):
    currentX = currentState[0]
    currentY = currentState[1]
    currentTheta = currentState[2]
    
    # hacky, because it could be outside interval <-PI, +PI> :(
    while currentTheta < -2 * pi:
      currentTheta = currentTheta + 2 * pi
    while currentTheta > 2 * pi:
      currentTheta = currentTheta - 2 * pi

    destinationX = destinationState[0]
    destinationY = destinationState[1]

    deltaX = destinationX - currentX
    deltaY = destinationY - currentY

    angle_to_destination = atan2(deltaY, deltaX)

    #https://stackoverflow.com/questions/1878907/the-smallest-difference-between-2-angles

    angle_delta = currentTheta - angle_to_destination

    if (angle_delta > pi):
      angle_delta -= 2 * pi
    if (angle_delta < -pi):
      angle_delta += 2 * pi

    if (angle_delta < - angle_epsilon):
      # turn on minimal radius
      velocity = vri
      omega = velocity / minimal_radius
    elif (angle_delta > + angle_epsilon):
      # turn on minimal radius
      velocity = vri
      omega = -velocity / minimal_radius
    else:
      # go straight
      velocity = vri
      omega = 0

    if velocity > highVelocityLimit:
      velocity = highVelocityLimit
    if (velocity < lowVelocityLimit):
      velocity = lowVelocityLimit
    if omega > highOmegaLimit:
      omega = highOmegaLimit
    if (omega < lowOmegaLimit):
      omega = lowOmegaLimit

    return velocity, omega
  return controller

"""### Fuzzy Logic Controller

The Fuzzy Logic Controller (FLC) has been designed based on [2], [3], [4], [5] of this paper.

A brief of the FLC is described below:

A structure of a fuzzy logic controller is shown in figure below:

![Picture1.png](data:image/png;base64,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)

The FLC mainly contains three operations: the fuzzification, the inference, and the defuzzification.

This controller has 02 inputs and 02 outputs. 

**The 02 INPUTS:** DISTANCE_ERROR AND THETA_ERROR

- The "DISTANCE_ERROR" is the distance from the current position of the robot to the destination position of the destination. Its unit is meter (m), in this experiment I set it is in range $[0, 10]$.

- The "THETA_ERROR" is the different angle between the current orientation of the robot with the line of sight angle from current possition of the robot to the destination. Its unit is radian (rad), and its value is in range $[-\pi\ , \pi]$.

**The 02 OUTPUTS:** omega_R and omega_L

  + The omega_R is the angular velocity of the right wheel of the robot. Its unit is ($rads^{-1}$), in this experiment it is in range [0, 30]$rads^{-1}$.

  + The omega_L is the angular velocity of the left wheel of the robot. Its unit is ($rads^{-1}$), in this experiment it is in range [0, 30]$rads^{-1}$.

**FUZZIFICATION:** In this experiment the memberships have been presented as below:
 
  + Membership functions for the DISTANCE_ERROR is Triangular. The parameters of the input DISTANCE_ERROR are in the table I below:

  \begin{array}\hline
    \text{Table I:  DISTANCE_ERROR (m)}
  \end{array}
   \begin{array}{|c | c |c |c |}\hline
     \text{Name} & \text{Acronyms} & \text{Values}\\\hline
     Very Close   & VC     & [0, 0, 2.5]    \\\hline
     Close        & C      & [0, 2.5, 5]    \\\hline
     Medium       & M      & [2.5, 5, 7.5]    \\\hline
     Far          & F      & [5, 7.5, 10]    \\\hline
     Very Far     & VF     & [7.5, 10, 10]    \\\hline
  \end{array} 

   + Membership functions for the THETA_ERROR is Triangular. The parameters of the input THETA_ERROR are in the table Ii below:

  \begin{array}\hline\
    \text{Table iI:   THETA_ERROR (rad)}
  \end{array}
  \begin{array}{|c | c |c |c |}\hline    
     \text{Name} & \text{Acronyms} & \text{Values}\\\hline
     Big Negative   & BN     & [-3.14, -3.14, -1.57]   \\\hline
     Negative       & N      & [-3.14, -1.57, 0]       \\\hline
     Zero           & Z      & [-1.57, 0, 1.57]        \\\hline
     Positive       & P      & [0, 1.57, 3.14]         \\\hline
     Big Positive   & BP     & [1.57, 3.14, 3.14]      \\\hline
  \end{array} 


  + Membership functions for omega_R and omega_L  are Triangulars. The parameters of the output omega_R and omega_L are in the table III below:

  \begin{array}\hline
    \text{Table III:  omega_R, omega_L ($rads^{-1}$)}
  \end{array}
  \begin{array}{|c | c |c |c |}\hline
     \text{Name} & \text{Acronyms} & \text{Values}\\\hline
     Very Small   & VS     & [0, 0, 7.5]      \\\hline
     Small        & S      & [0, 7.5, 15]     \\\hline
     Medium Big   & MB      & [7.5, 15, 22.5]    \\\hline
     Big          & B      & [15, 22.5, 30]    \\\hline
     Very Big     & VB     & [22.5, 30, 30]    \\\hline
  \end{array} 

It can be expressed in the table IV below:

\begin{array}\hline
  \text{Table IV:  The rules for omega_R}
\end{array}
\begin{array}{|c | c |c |c |}\hline
     \text{ $\Delta D$ \ $\Delta \Theta$} & \text{ BN } & \text{ N } & \text{ Z } & \text{ P } & \text{ BP }\\\hline
     VC   & VSR     & SR    & VSR   & BR    & VBR   \\\hline
     C    & VSR     & SR    & SR    & BR    & VBR   \\\hline
     M    & VSR     & SR    & MBR   & BR    & VBR   \\\hline
     F    & VSR     & SR    & BR    & BR    & VBR   \\\hline
     VF   & VSR     & SR    & VBR   & BR    & VBR   \\\hline
\end{array} 

It can be expressed in the table V below:

\begin{array}\hline
  \text{Table V:  The rules for omega_L}
\end{array}
\begin{array}{|c | c |c |c |}\hline
     \text{ $\Delta D$ \ $\Delta \Theta$} & \text{ BN } & \text{ N } & \text{ Z } & \text{ P } & \text{ BP }\\\hline
     VC   & VBL     & BL    & VSL   & SL    & VSL   \\\hline
     C    & VBL     & BL    & SL    & SL    & VSL   \\\hline
     M    & VBL     & BL    & MBL   & SL    & VSL   \\\hline
     F    & VBL     & BL    & BL    & SL    & VSL   \\\hline
     VF   & VBL     & BL    & VBL   & SL    & VSL   \\\hline
\end{array} 

**DEFUZZIFICATION:** Use "Centreoid of area" defuzzification method (centroid)

#### Helper Functions

Helper functions have been introduced here for encapsulation of fuzzy system construction.
"""

def createFuzzyfier(space, categories, trimf = fuzz.trimf, membership = fuzz.interp_membership):
    fuzzyInput = {}
    for key, value in categories.items():
        fuzzyInput[key] = trimf(space, value)
    def result(variable):
        output = {}
        for key, value in fuzzyInput.items():
            cValue = membership(space, value, variable)
            if cValue <= 0:
                output[key] = 1e-5
            else:
                output[key] = cValue
        return output
    return result

def createFuzzyfier(space, categories, trimf = fuzz.trimf, membership = fuzz.interp_membership):
    fuzzyInput = {}
    for key, value in categories.items():
        fuzzyInput[key] = trimf(space, value)
    def result(variable):
        output = {}
        for key, value in fuzzyInput.items():
            output[key] = membership(space, value, variable)
        if output[key] ==0:
            output[key] = 1e-5
        #else:
        #    output[key] = output[key] 
        return output
    return result

def createInferenceSystem(inputAfuzzyfier, inputBfuzzyfier, outputSpace, outputDict, rulesDict, trimf = fuzz.trimf):
    fuzzyResults = {}
    for keyA, outerValue in rulesDict.items():
        if not(keyA in fuzzyResults):
            fuzzyResults[keyA] = {}
        for keyB, innerValue in outerValue.items():
            fuzzyResults[keyA][keyB] = trimf(outputSpace, outputDict[innerValue]) #innerValue==outputDict[keyA][keyB]
    def result(valueA, valueB):
        fuzzyVariableA = inputAfuzzyfier(valueA)
        fuzzyVariableB = inputBfuzzyfier(valueB)
        fuzzyResult = None
        for keyA, outerValue in rulesDict.items():
            for keyB, resultValue in outerValue.items():
                currentResult = np.fmin(fuzzyResults[keyA][keyB],
                    np.fmin(fuzzyVariableA[keyA], fuzzyVariableB[keyB]))
                if fuzzyResult is None:
                    fuzzyResult = currentResult
                else:
                    fuzzyResult = np.fmax(currentResult, fuzzyResult)
        return fuzzyResult
    return result

def createDefuzzyfier(outputSpace, *defuzzArgs, defuzz=fuzz.defuzz, **defuzzKwargs):
    def result(value):
        return defuzz(outputSpace, value, *defuzzArgs, **defuzzKwargs)
    return result
  
def createFullFuzzySystem(inferenceSystem, defuzzyfier):
    def system(inputA, inputB):
        return defuzzyfier(inferenceSystem(inputA, inputB))
    return system

"""#### Controller"""

def createFuzzyController(fuzzyDescription, r, b, omega_ri, vri, lowVelocityLimit, highVelocityLimit, lowOmegaLimit, highOmegaLimit):
    inputsDistance = fuzzyDescription['inputs']['distance']['M']
    inputsSpaceDistance = np.array(fuzzyDescription['inputs']['distance']['S'])
    
    inputsAngle = fuzzyDescription['inputs']['angle']['M']
    inputsSpaceAngle = np.array(fuzzyDescription['inputs']['angle']['S'])
    
    outputsOmegaR = fuzzyDescription['outputs']['omegaR']['M']
    outputSpaceOmegaR = np.array(fuzzyDescription['outputs']['omegaR']['S'])
    outputRulesOmegaR = fuzzyDescription['outputs']['omegaR']['rules']
    
    outputsOmegaL = fuzzyDescription['outputs']['omegaL']['M']
    outputSpaceOmegaL = np.array(fuzzyDescription['outputs']['omegaL']['S'])
    outputRulesOmegaL = fuzzyDescription['outputs']['omegaL']['rules']


    inputsDistanceFuzzyfier = createFuzzyfier(inputsSpaceDistance, inputsDistance)
    inputsAngleFuzzyfier = createFuzzyfier(inputsSpaceAngle, inputsAngle)

    inferenceSystem_R = createInferenceSystem(inputsDistanceFuzzyfier, inputsAngleFuzzyfier, outputSpaceOmegaR, outputsOmegaR, outputRulesOmegaR)
    outputDefuzzyfier_R = createDefuzzyfier(outputSpaceOmegaL, mode='centroid')

    inferenceSystem_L = createInferenceSystem(inputsDistanceFuzzyfier, inputsAngleFuzzyfier, outputSpaceOmegaL, outputsOmegaL, outputRulesOmegaL)
    outputDefuzzyfier_L = createDefuzzyfier(outputSpaceOmegaL, mode='centroid')

    fullSystem_R = createFullFuzzySystem(inferenceSystem_R, outputDefuzzyfier_R)
    fullSystem_L = createFullFuzzySystem(inferenceSystem_L, outputDefuzzyfier_L)
    
    def controller(t, currentState, destinationState):
        currentX = currentState[0]
        currentY = currentState[1]
        currentTheta = currentState[2]

        destinationX = destinationState[0]
        destinationY = destinationState[1]

        cosTheta = cos(currentTheta)
        sinTheta = sin(currentTheta)
        
        deltaX = destinationX - currentX
        deltaY = destinationY - currentY
        theta_destination = atan2(deltaY, deltaX)
        THETA_ERROR = theta_destination - currentTheta
        DISTANCE_ERROR = sqrt(deltaX * deltaX + deltaY * deltaY)
        
        if (THETA_ERROR > pi):
            THETA_ERROR -= 2*pi
        if (THETA_ERROR < -pi):
            THETA_ERROR += 2*pi
      
        omega_R = fullSystem_R(DISTANCE_ERROR, THETA_ERROR)
        omega_L = fullSystem_L(DISTANCE_ERROR, THETA_ERROR)

        velocity = r * (omega_R + omega_L) / 2
        omega = r * (omega_R - omega_L) / b

        if velocity > highVelocityLimit:
            velocity = highVelocityLimit
        if (velocity < lowVelocityLimit):
            velocity = lowVelocityLimit
        if omega > highOmegaLimit:
            omega = highOmegaLimit
        if (omega < lowOmegaLimit):
            omega = lowOmegaLimit

        return velocity, omega
    return controller

"""## Simulation Function

In next part the full description of simulation is stored in a single structured JSON document / variable. If this document is mutated, the slighly different condition for simulation are defined. Set of mutated documents and results of described simulations might be compared and thus proper results can be selected. This process creates a basement for optimization techniques.

### Simulation Description
"""

simulationDescription = {

    'robotState0': {
        'x': 0,
        'y': 0,
        'theta': -3.14 / 4
    },

    'path': [
        [0, 0, 0],  #X, Y, orientation
        [10, 0, 0], #X, Y, orientation
        [10, 10, 0], #X, Y, orientation
        [20, 10, 0], #X, Y, orientation
        [20, 20, 0]
    ],

    'robotParams': {
        'r': 0.0925,
        'b': 0.37,
        'm': 9,
        'I': 0.16245,
        #'motorParams': None,
        'motorParams': {
            'J': 0.01,
            'B': 0.1,

            'Kt': 0.01,
            'Ke': 0.01,
            'K': 0.01,

            'Ra': 0.1,
            'La': 0.01
        }
    },
    
    'controllerParams': {
        'omega_ri': 0, 'vri': 2.0,'lowVelocityLimit': 0.2, 
        'highVelocityLimit': 2.0, 'lowOmegaLimit': -0.75, 'highOmegaLimit': 0.75
    },

    'simulationParams': {
        't0': 0,
        't_bound': 100,
        'max_step': 0.05
    }
}

"""### Executor

The next function is core of simulation. Others functions including all fitness functions are build on it.
"""

def runSimulation(simulationDescription, controllerCreator, selectors=selectors):
  
    pathForSimulation = iter(simulationDescription['path'])

    t0 = simulationDescription['simulationParams']['t0']
    t_bound = simulationDescription['simulationParams']['t_bound']
    max_step = simulationDescription['simulationParams']['max_step']

    state0 = None
    robotState0 = simulationDescription['robotState0']
    if robot == robotWithDynamic:
        state0 = np.array([robotState0['x'], robotState0['y'], robotState0['theta'], 0, 0, 0, 0, 0, 0, 0]) # x0=0, y0=0, theta
    else:
        state0 = np.array([robotState0['x'], robotState0['y'], robotState0['theta'], 0, 0, 0]) # x0=0, y0=0,theta

    solverfunc = simpleCompute(
        compute, state0 = state0, 
        t0 = t0, t_bound = t_bound, max_step = max_step)

    controllerParams = simulationDescription['controllerParams']
    completeRobot = robotModelCreator(controllerCreator, pathForSimulation, **controllerParams)      
    robotStates = solverfunc(completeRobot)

    results = {}
    for key, selector in selectors.items():
        results[key] = []

    for currentState in robotStates: # readout all states from current moving robot
        for key, selector in selectors.items():
            results[key].append(selector(currentState))

    return results

"""### Example of Use"""

import copy

def localDemo():
    circleControllerDescription = copy.deepcopy(simulationDescription)
    circleControllerDescription['controllerParams']['gain'] = 4

    results = runSimulation(circleControllerDescription, createCircleControllerWithGain, selectors)
    plt.plot(results['x'], results['y'])
    
if _runDemos:
    localDemo()

"""## Chromozome Mapping Functions

These functions change a standard simulation data structure description into the data structure description based on information stored in a chromosome. Also these functions could be named as a chromosome information decoders.

### Circle Controller
"""

import copy
def fromChromozomeToDescriptionCircle(chromozome, description):
    result = copy.deepcopy(description)
    result['controllerParams']['gain'] = chromozome[0]
    return result

"""### Robins Controller"""

import copy
def fromChromozomeToDescriptionRobins(chromozome, description):
    result = copy.deepcopy(description)
    result['controllerParams']['k0'] = chromozome[0]
    result['controllerParams']['k1'] = chromozome[1]
    return result

"""### Chaudhari-based controller"""

import copy
def fromChromozomeToDescriptionChaudhari(chromozome, description):
    result = copy.deepcopy(description)
    result['controllerParams']['radius'] = chromozome[0]
    return result

"""### Fuzzy Logic Controller

#### Chromosome Explanation
"""

# full distance chromosome part
#_chromozomeDistanceM = [2.5, 2.5, 2.5, 2.5, 2.5, 5, 2.5, 2.5, 7.5, 2.5, 2.5] 
_chromozomeDistanceMPeaks = [2.5, 5, 7.5] # <0.1; 9.9>
_chromozomeDistanceM = [2.5 for i in range(11)]
_chromozomeDistanceM[2] = _chromozomeDistanceMPeaks[0]
_chromozomeDistanceM[5] = _chromozomeDistanceMPeaks[1]
_chromozomeDistanceM[8] = _chromozomeDistanceMPeaks[2]

# full angle chromosome part
#_chromozomeAngleM = [1.57, 1.57, -1.57, 1.57, 1.57, 0, 1.57, 1.57, 1.57, 1.57, 1.57] #11-21, peaks 13,16,19, widths 11,12/14,15/17,18/20,21
_chromozomeAngleMPeaks = [-1.57, 0, 1.57] # <-3.1; 3.1>
_chromozomeAngleM = [1.57 for i in range(11)]
_chromozomeAngleM[2] = _chromozomeAngleMPeaks[0]
_chromozomeAngleM[5] = _chromozomeAngleMPeaks[1]
_chromozomeAngleM[8] = _chromozomeAngleMPeaks[2]

# full omegaR chromosome part
#_chromozomeOmegaRM = [7.5, 7.5, 7.5, 7.5, 7.5, 15, 7.5, 7.5, 22.5, 7.5, 7.5] #22-32, peaks 24,27,30, widths 22,23/25,26/28,29/31,32
_chromozomeOmegaRMPeaks = [7.5, 15, 22.5] # <0.1; 29.9>
_chromozomeOmegaRM = [7.5 for i in range(11)]
_chromozomeOmegaRM[2] = _chromozomeOmegaRMPeaks[0]
_chromozomeOmegaRM[5] = _chromozomeOmegaRMPeaks[1]
_chromozomeOmegaRM[8] = _chromozomeOmegaRMPeaks[2]

# full omegaL chromosome part
#_chromozomeOmegaLM = [7.5, 7.5, 7.5, 7.5, 7.5, 15, 7.5, 7.5, 22.5, 7.5, 7.5] #33-43, peaks 35,38,41, widths 33,34/36,37/39,40/42,43    
_chromozomeOmegaLMPeaks = [7.5, 15, 22.5]
_chromozomeOmegaLM = [7.5 for i in range(11)]
_chromozomeOmegaLM[2] = _chromozomeOmegaLMPeaks[0]
_chromozomeOmegaLM[5] = _chromozomeOmegaLMPeaks[1]
_chromozomeOmegaLM[8] = _chromozomeOmegaLMPeaks[2]

_fullFLCChromosome = [*_chromozomeDistanceM, *_chromozomeAngleM, *_chromozomeOmegaRM, *_chromozomeOmegaLM]

"""#### Lowest and Highest Values of Chromosome"""

# full distance chromosome part
#_chromozomeDistanceM = [2.5, 2.5, 2.5, 2.5, 2.5, 5, 2.5, 2.5, 7.5, 2.5, 2.5]  #0-10, peaks 2,5,8, widths 0,1/3,4/6,7/9,10
_chromozomeDistanceMLo = [0.1 for i in range(11)]
_chromozomeDistanceMHi = [10 for i in range(11)]

# full angle chromosome part
#_chromozomeAngleM = [1.57, 1.57, -1.57, 1.57, 1.57, 0, 1.57, 1.57, 1.57, 1.57, 1.57] #11-21, peaks 13,16,19, widths 11,12/14,15/17,18/20,21

_chromozomeAngleMPeaksLo = [-3.1, -3.1, -3.1] # <-3.1; 3.1>
_chromozomeAngleMPeaksHi = [3.1, 3.1, 3.1] # <-3.1; 3.1>
_chromozomeAngleMLo = [0.1 for i in range(11)]
_chromozomeAngleMHi = [3.1 for i in range(11)]
_chromozomeAngleMLo[2] = _chromozomeAngleMPeaksLo[0]
_chromozomeAngleMLo[5] = _chromozomeAngleMPeaksLo[1]
_chromozomeAngleMLo[8] = _chromozomeAngleMPeaksLo[2]
_chromozomeAngleMHi[2] = _chromozomeAngleMPeaksHi[0]
_chromozomeAngleMHi[5] = _chromozomeAngleMPeaksHi[1]
_chromozomeAngleMHi[8] = _chromozomeAngleMPeaksHi[2]

# full omegaR chromosome part
#_chromozomeOmegaRM = [7.5, 7.5, 7.5, 7.5, 7.5, 15, 7.5, 7.5, 22.5, 7.5, 7.5] #22-32, peaks 24,27,30, widths 22,23/25,26/28,29/31,32
_chromozomeOmegaRMLo = [0.1 for i in range(11)]
_chromozomeOmegaRMHi = [29.9 for i in range(11)]

# full omegaL chromosome part
#_chromozomeOmegaLM = [7.5, 7.5, 7.5, 7.5, 7.5, 15, 7.5, 7.5, 22.5, 7.5, 7.5] #33-43, peaks 35,38,41, widths 33,34/36,37/39,40/42,43
_chromozomeOmegaLMLo = [0.1 for i in range(11)]
_chromozomeOmegaLMHi = [29.9 for i in range(11)]

_fullFLCChromosomeLo = [*_chromozomeDistanceMLo, *_chromozomeAngleMLo, *_chromozomeOmegaRMLo, *_chromozomeOmegaLMLo]
_fullFLCChromosomeHi = [*_chromozomeDistanceMHi, *_chromozomeAngleMHi, *_chromozomeOmegaRMHi, *_chromozomeOmegaLMHi]

def localDemo():
    print(_fullFLCChromosome)
    print(_fullFLCChromosomeLo)
    print(_fullFLCChromosomeHi)
    
if _runDemos:
    localDemo()

"""#### Chromosome Transformation"""

import copy
def fromChromozomeToDescriptionFuzzy(chromozome, description):
    CH = chromozome # just for simplicity
    result = copy.deepcopy(description)

    fuzzyDescription = {
        'inputs': {
            'distance' : {
                'S': list(np.arange(0, 10, 0.1)),
                'M': {'VC': [0, 0, 2.5], 'C': [0, 2.5, 5], 'M': [2.5, 5, 7.5], 'F': [5, 7.5, 10], 'VF': [7.5, 10, 10]}
            },
            'angle' : {
                'S': list(np.arange(-3.14, 3.14, 0.0628)),
                'M': {'BN': [-3.14, -3.14, -1.57], 'N': [-3.14, -1.57, 0], 'Z': [-1.57, 0, 1.57], 'P': [0, 1.57, 3.14], 'BP': [1.57, 3.14, 3.14]}
            }
        },
        'outputs': {
            'omegaR': {
                'S': list(np.arange(0, 30, 0.3)),
                'rules': {
                    'VC': {'BN': 'VSR', 'N': 'SR', 'Z': 'VSR', 'P': 'BR', 'BP': 'VBR'},
                    'C': {'BN': 'VSR', 'N': 'SR', 'Z': 'SR', 'P': 'BR', 'BP': 'VBR'},
                    'M': {'BN': 'VSR', 'N': 'SR', 'Z': 'MBR', 'P': 'BR', 'BP': 'VBR'},
                    'F': {'BN': 'VSR', 'N': 'SR', 'Z': 'BR', 'P': 'BR', 'BP': 'VBR'},
                    'VF': {'BN': 'VSR', 'N': 'SR', 'Z': 'VBR', 'P': 'BR', 'BP': 'VBR'}
                },
                'mode': 'centroid',
                'M': {'VSR': [0, 0, 7.5], 'SR': [0, 7.5, 15], 'MBR': [7.5, 15, 22.5], 'BR': [15, 22.5, 30], 'VBR': [22.5, 30, 30]}
            },
            'omegaL': {
                'S': list(np.arange(0, 30, 0.3)),
                'rules': {
                    'VC': {'BN': 'VBL', 'N': 'BL', 'Z': 'VSL', 'P': 'SL', 'BP': 'VSL'},
                    'C': {'BN': 'VBL', 'N': 'BL', 'Z': 'SL', 'P': 'SL', 'BP': 'VSL'},
                    'M': {'BN': 'VBL', 'N': 'BL', 'Z': 'MBL', 'P': 'SL', 'BP': 'VSL'},
                    'F': {'BN': 'VBL', 'N': 'BL', 'Z': 'BL', 'P': 'SL', 'BP': 'VSL'},
                    'VF': {'BN': 'VBL', 'N': 'BL', 'Z': 'VBL', 'P': 'SL', 'BP': 'VSL'} 
                },
                'mode': 'centroid',
                'M': {'VSL': [0, 0, 7.5], 'SL': [0, 7.5, 15], 'MBL': [7.5, 15, 22.5], 'BL': [15, 22.5, 30], 'VBL': [22.5, 30, 30]}
            }
        }
    }     


    
    distance_Member = {'VC': [0, 0, CH[0]], 
                       'C': [CH[2] - CH[1], CH[2], CH[2] + CH[3]],
                       'M': [CH[5] - CH[4], CH[5], CH[5] + CH[6]],
                       'F': [CH[8] - CH[7], CH[8], CH[8] + CH[9]], 
                       'VF': [10 - CH[10], 10, 10]}
    fuzzyDescription['inputs']['distance']['M'] = distance_Member

    angle_Member = {'BN': [-3.14, -3.14, -3.14+CH[11]], 
                    'N': [CH[13] - CH[12], CH[13], CH[13] + CH[14]],
                    'Z': [CH[16] - CH[15], CH[16], CH[16] + CH[17]], 
                    'P': [CH[19] - CH[18], CH[19], CH[19] + CH[20]], 
                    'BP': [3.14 - CH[21], 3.14, 3.14]}    
    fuzzyDescription['inputs']['angle']['M'] = angle_Member

    omegaR_Member =  {'VSR': [0, 0, CH[22]], 
                      'SR': [CH[24] - CH[23], CH[24], CH[24] + CH[25]],
                      'MBR': [CH[27] - CH[26], CH[27], CH[27] + CH[28]], 
                      'BR': [CH[30] - CH[29], CH[30], CH[30] + CH[31]], 
                      'VBR': [30 - CH[32], 30, 30]}
    fuzzyDescription['outputs']['omegaR']['M'] = omegaR_Member

    omegaL_Member =  {'VSL': [0, 0, CH[33]], 
                      'SL': [CH[35] - CH[34], CH[35], CH[35] + CH[36]],
                      'MBL': [CH[38] - CH[37], CH[38], CH[38] + CH[39]], 
                      'BL': [CH[41] - CH[40], CH[41], CH[41] + CH[42]], 
                      'VBL': [30 - CH[43], 30, 30]}
    fuzzyDescription['outputs']['omegaL']['M'] = omegaL_Member

    result['controllerParams']['fuzzyDescription'] = fuzzyDescription
    
    result['controllerParams']['r'] = result['robotParams']['r']
    result['controllerParams']['b'] = result['robotParams']['b']
    return result

"""### Chromosome Transformation used for Thoa-based control"""

import copy
def fromChromozomeToDescriptionFuzzy_Thoa(chromozome, description):
    CH = chromozome # just for simplicity
    result = copy.deepcopy(description)

    fuzzyDescription = {
        'inputs': {
            'distance' : {
                'S': list(np.arange(0, 10, 0.1)),
                'M': {'VC': [0, 0, 2.5], 'C': [0, 2.5, 5], 'M': [2.5, 5, 7.5], 'F': [5, 7.5, 10], 'VF': [7.5, 10, 10]}
            },
            'angle' : {
                'S': list(np.arange(-3.14, 3.14, 0.0628)),
                'M': {'BN': [-3.14, -3.14, -1.57], 'N': [-3.14, -1.57, 0], 'Z': [-1.57, 0, 1.57], 'P': [0, 1.57, 3.14], 'BP': [1.57, 3.14, 3.14]}
            }
        },
        'outputs': {
            'omegaR': {
                'S': list(np.arange(0, 30, 0.3)),
                'rules': {
                    'VC': {'BN': 'VSR', 'N': 'SR',  'Z': 'VSR', 'P': 'VBR', 'BP': 'VBR'},
                    'C':  {'BN': 'VSR', 'N': 'VSR', 'Z': 'SR',  'P': 'VBR', 'BP': 'VBR'},
                    'M':  {'BN': 'VSR', 'N': 'SR',  'Z': 'MBR', 'P': 'VBR', 'BP': 'VBR'},
                    'F':  {'BN': 'VSR', 'N': 'SR',  'Z': 'BR',  'P': 'VBR', 'BP': 'VBR'},
                    'VF': {'BN': 'VSR', 'N': 'SR',  'Z': 'VBR', 'P': 'VBR', 'BP': 'VBR'}
                },
                'mode': 'centroid',
                'M': {'VSR': [0, 0, 7.5], 'SR': [0, 7.5, 15], 'MBR': [7.5, 15, 22.5], 'BR': [15, 22.5, 30], 'VBR': [22.5, 30, 30]}
            },
            'omegaL': {
                'S': list(np.arange(0, 30, 0.3)),
                'rules': {
                    'VC': {'BN': 'VBL', 'N': 'VBL', 'Z': 'VSL', 'P': 'SL', 'BP': 'VSL'},
                    'C':  {'BN': 'VBL', 'N': 'VBL', 'Z': 'SL',  'P': 'SL', 'BP': 'VSL'},
                    'M':  {'BN': 'VBL', 'N': 'VBL', 'Z': 'MBL', 'P': 'SL', 'BP': 'VSL'},
                    'F':  {'BN': 'VBL', 'N': 'VBL', 'Z': 'BL',  'P': 'SL', 'BP': 'VSL'},
                    'VF': {'BN': 'VBL', 'N': 'VBL', 'Z': 'VBL', 'P': 'SL', 'BP': 'VSL'} 
                },
                'mode': 'centroid',
                'M': {'VSL': [0, 0, 7.5], 'SL': [0, 7.5, 15], 'MBL': [7.5, 15, 22.5], 'BL': [15, 22.5, 30], 'VBL': [22.5, 30, 30]}
            }
        }
    }     


    
    distance_Member = {'VC': [0, 0, CH[0]], 
                       'C': [CH[2] - CH[1], CH[2], CH[2] + CH[3]],
                       'M': [CH[5] - CH[4], CH[5], CH[5] + CH[6]],
                       'F': [CH[8] - CH[7], CH[8], CH[8] + CH[9]], 
                       'VF': [10 - CH[10], 10, 10]}
    fuzzyDescription['inputs']['distance']['M'] = distance_Member

    angle_Member = {'BN': [-3.14, -3.14, -3.14+CH[11]], 
                    'N': [CH[13] - CH[12], CH[13], CH[13] + CH[14]],
                    'Z': [CH[16] - CH[15], CH[16], CH[16] + CH[17]], 
                    'P': [CH[19] - CH[18], CH[19], CH[19] + CH[20]], 
                    'BP': [3.14 - CH[21], 3.14, 3.14]}    
    fuzzyDescription['inputs']['angle']['M'] = angle_Member

    omegaR_Member =  {'VSR': [0, 0, CH[22]], 
                      'SR': [CH[24] - CH[23], CH[24], CH[24] + CH[25]],
                      'MBR': [CH[27] - CH[26], CH[27], CH[27] + CH[28]], 
                      'BR': [CH[30] - CH[29], CH[30], CH[30] + CH[31]], 
                      'VBR': [30 - CH[32], 30, 30]}
    fuzzyDescription['outputs']['omegaR']['M'] = omegaR_Member

    omegaL_Member =  {'VSL': [0, 0, CH[33]], 
                      'SL': [CH[35] - CH[34], CH[35], CH[35] + CH[36]],
                      'MBL': [CH[38] - CH[37], CH[38], CH[38] + CH[39]], 
                      'BL': [CH[41] - CH[40], CH[41], CH[41] + CH[42]], 
                      'VBL': [30 - CH[43], 30, 30]}
    fuzzyDescription['outputs']['omegaL']['M'] = omegaL_Member

    result['controllerParams']['fuzzyDescription'] = fuzzyDescription
    
    result['controllerParams']['r'] = result['robotParams']['r']
    result['controllerParams']['b'] = result['robotParams']['b']
    return result

"""### Chromosome Transformation used for Expert-based FLCl"""

import copy
def fromChromozomeToDescriptionFuzzy_Expert(chromozome, description):
    CH = chromozome # just for simplicity
    result = copy.deepcopy(description)

    fuzzyDescription = {
        'inputs': {
            'distance' : {
                'S': list(np.arange(0, 10, 0.1)),
                'M': {'VC': [0, 0, 1], 'NC': [0, 1, 2], 'C': [1, 2, 3], 'M': [2, 3, 5], 'NF': [3, 5, 7], 'F': [5, 7, 10], 'VF': [7, 10, 10]}
            },
            'angle' : {
                'S': list(np.arange(-3.14, 3.14, 0.0628)),
                'M': {'VBN': [-3.14, -3.14, -1.57], 'BN': [-3.14, -1.57, -0.785], 'N': [-1.57, -0.785, 0], 'Z': [-0.785, 0, 0.785], 'P': [0, 0.785, 1.57], 'BP': [0.785, 1.57, 3.14], 'VBP': [1.57, 3.14, 3.14]}
            }
        },
        'outputs': {
            'omegaR': {
                'S': list(np.arange(0, 30, 0.3)),
                'rules': {
                    'VC': {'VBN': 'VSR', 'BN': 'SR',  'N': 'NMBR',  'Z': 'VSR',  'P': 'NBR',   'BP': 'BR', 'VBP': 'VBR'},
                    'NC': {'VBN': 'VSR', 'BN': 'SR',  'N': 'NMBR',  'Z': 'SR',   'P': 'NBR',   'BP': 'BR', 'VBP': 'VBR'},
                    'C':  {'VBN': 'VSR', 'BN': 'SR',  'N': 'NMBR',  'Z': 'NMBR', 'P': 'NBR',   'BP': 'BR', 'VBP': 'VBR'},
                    'M':  {'VBN': 'VSR', 'BN': 'SR',  'N': 'NMBR',  'Z': 'MBR',  'P': 'NBR',   'BP': 'BR', 'VBP': 'VBR'},
                    'NF': {'VBN': 'VSR', 'BN': 'SR',  'N': 'NMBR',  'Z': 'NBR',  'P': 'NBR',   'BP': 'BR', 'VBP': 'VBR'},
                    'F':  {'VBN': 'VSR', 'BN': 'SR',  'N': 'NMBR',  'Z': 'BR',   'P': 'NBR',   'BP': 'BR', 'VBP': 'VBR'},
                    'VF': {'VBN': 'VSR', 'BN': 'SR',  'N': 'NMBR',  'Z': 'VBR',  'P': 'NBR',   'BP': 'BR', 'VBP': 'VBR'}
                },
                'mode': 'centroid',
                'M': {'VSR': [0, 0, 5], 'SR': [0, 5, 10], 'NMBR': [5, 10, 15], 'MBR': [10, 15, 20], 'NBR': [15, 20, 25], 'BR': [20, 25, 30], 'VBR': [25, 30, 30]}
            },
            'omegaL': {
                'S': list(np.arange(0, 30, 0.3)),
                'rules': {
                    'VC': {'VBN': 'VBL',  'BN': 'BL', 'N': 'NBL',  'Z': 'VSL',  'P': 'NMBL',  'BP': 'SL', 'VBP': 'VSL'},
                    'NC': {'VBN': 'VBL',  'BN': 'BL', 'N': 'NBL',  'Z': 'SL',   'P': 'NMBL',  'BP': 'SL',  'VBP': 'VSL'},
                    'C':  {'VBN': 'VBL',  'BN': 'BL', 'N': 'NBL',  'Z': 'NMBL', 'P': 'NMBL',  'BP': 'SL',   'VBP': 'VSL'},
                    'M':  {'VBN': 'VBL',  'BN': 'BL', 'N': 'NBL',  'Z': 'MBL',  'P': 'NMBL',  'BP': 'SL',   'VBP': 'VSL'},
                    'NF': {'VBN': 'VBL',  'BN': 'BL', 'N': 'NBL',  'Z': 'NBL',  'P': 'NMBL',  'BP': 'SL',   'VBP': 'VSL'},
                    'F':  {'VBN': 'VBL',  'BN': 'BL', 'N': 'NBL',  'Z': 'BL',   'P': 'NMBL',  'BP': 'SL',   'VBP': 'VSL'},
                    'VF': {'VBN': 'VBL',  'BN': 'BL', 'N': 'NBL',  'Z': 'VBL',  'P': 'NMBL',  'BP': 'SL',   'VBP': 'VSL'}
                },
                'mode': 'centroid',
                'M': {'VSL': [0, 0, 5], 'SL': [0, 5, 10], 'NMBL': [5, 10, 15], 'MBL': [10, 15, 20], 'NBL': [15, 20, 25], 'BL': [20, 25, 30], 'VBL': [25, 30, 30]}
            }
        }
    }     

    
    distance_Member = {'VC': [0, 0, CH[0]], 
                       'NC': [CH[2] - CH[1], CH[2], CH[2] + CH[3]],
                       'C':  [CH[5] - CH[4], CH[5], CH[5] + CH[6]],
                       'M':  [CH[8] - CH[7], CH[8], CH[8] + CH[9]],
                       'NF': [CH[11] - CH[10], CH[11], CH[11] + CH[12]],
                       'F': [CH[14] - CH[13], CH[14], CH[14] + CH[15]], 
                       'VF': [10 - CH[16], 10, 10]}
    fuzzyDescription['inputs']['distance']['M'] = distance_Member

    angle_Member = {'VBN': [-3.14, -3.14, -3.14+CH[17]], 
                    'BN':  [CH[19] - CH[18], CH[19], CH[19] + CH[20]],
                    'N':   [CH[22] - CH[21], CH[22], CH[22] + CH[23]], 
                    'Z':   [CH[25] - CH[24], CH[25], CH[25] + CH[26]],
                    'P':   [CH[28] - CH[27], CH[28], CH[28] + CH[29]],
                    'BP':  [CH[31] - CH[30], CH[31], CH[31] + CH[32]], 
                    'VBP': [3.14 - CH[33], 3.14, 3.14]}    
    fuzzyDescription['inputs']['angle']['M'] = angle_Member

    omegaR_Member =  {'VSR':  [0, 0, CH[34]], 
                      'SR':   [CH[36] - CH[35], CH[36], CH[36] + CH[37]],
                      'NMBR': [CH[39] - CH[38], CH[39], CH[39] + CH[40]], 
                      'MBR':  [CH[42] - CH[41], CH[42], CH[42] + CH[43]],
                      'NBR':  [CH[45] - CH[44], CH[45], CH[45] + CH[46]],
                      'BR':   [CH[48] - CH[47], CH[48], CH[48] + CH[49]], 
                      'VBR':  [30 - CH[50], 30, 30]}
    fuzzyDescription['outputs']['omegaR']['M'] = omegaR_Member

    omegaL_Member =  {'VSL':  [0, 0, CH[50]], 
                      'SL':   [CH[53] - CH[52], CH[53], CH[53] + CH[54]],
                      'NMBL': [CH[56] - CH[55], CH[56], CH[56] + CH[57]], 
                      'MBL':  [CH[59] - CH[58], CH[59], CH[59] + CH[60]],
                      'NBL':  [CH[62] - CH[61], CH[62], CH[62] + CH[63]], 
                      'BL':   [CH[65] - CH[64], CH[65], CH[65] + CH[66]],
                      'VBL':  [30 - CH[67], 30, 30]}
    fuzzyDescription['outputs']['omegaL']['M'] = omegaL_Member

    result['controllerParams']['fuzzyDescription'] = fuzzyDescription
    
    result['controllerParams']['r'] = result['robotParams']['r']
    result['controllerParams']['b'] = result['robotParams']['b']
    return result

"""### Chromosome Transformation used Mohammadian-based FLC_GA"""

import copy
def fromChromozomeToDescriptionFuzzy_Mohammadian(chromozome, description):
    CH = chromozome # just for simplicity
    result = copy.deepcopy(description)

    fuzzyDescription = {
        'inputs': {
            'distance' : {
                'S': list(np.arange(0, 10, 0.1)),
                'M': {'VC': [0, 0, 2.5], 'C': [0, 2.5, 5], 'M': [2.5, 5, 7.5], 'F': [5, 7.5, 10], 'VF': [7.5, 10, 10]}
            },
            'angle' : {
                'S': list(np.arange(-3.14, 3.14, 0.0628)),
                'M': {'BN': [-3.14, -3.14, -1.57], 'N': [-3.14, -1.57, 0], 'Z': [-1.57, 0, 1.57], 'P': [0, 1.57, 3.14], 'BP': [1.57, 3.14, 3.14]}
            }
        },
        'outputs': {
            'omegaR': {
                'S': list(np.arange(0, 30, 0.3)),
                'rules': {
                    'VC': {'BN': 'VSR', 'N': 'SR', 'Z': 'VSR', 'P': 'BR', 'BP': 'VBR'},
                    'C': {'BN': 'VSR', 'N': 'SR', 'Z': 'SR', 'P': 'BR', 'BP': 'VBR'},
                    'M': {'BN': 'VSR', 'N': 'SR', 'Z': 'MBR', 'P': 'BR', 'BP': 'VBR'},
                    'F': {'BN': 'VSR', 'N': 'SR', 'Z': 'BR', 'P': 'BR', 'BP': 'VBR'},
                    'VF': {'BN': 'VSR', 'N': 'SR', 'Z': 'VBR', 'P': 'BR', 'BP': 'VBR'}
                },
                'mode': 'centroid',
                'M': {'VSR': [0, 0, 7.5], 'SR': [0, 7.5, 15], 'MBR': [7.5, 15, 22.5], 'BR': [15, 22.5, 30], 'VBR': [22.5, 30, 30]}
            },
            'omegaL': {
                'S': list(np.arange(0, 30, 0.3)),
                'rules': {
                    'VC': {'BN': 'VBL', 'N': 'BL', 'Z': 'VSL', 'P': 'SL', 'BP': 'VSL'},
                    'C': {'BN': 'VBL', 'N': 'BL', 'Z': 'SL', 'P': 'SL', 'BP': 'VSL'},
                    'M': {'BN': 'VBL', 'N': 'BL', 'Z': 'MBL', 'P': 'SL', 'BP': 'VSL'},
                    'F': {'BN': 'VBL', 'N': 'BL', 'Z': 'BL', 'P': 'SL', 'BP': 'VSL'},
                    'VF': {'BN': 'VBL', 'N': 'BL', 'Z': 'VBL', 'P': 'SL', 'BP': 'VSL'} 
                },
                'mode': 'centroid',
                'M': {'VSL': [0, 0, 7.5], 'SL': [0, 7.5, 15], 'MBL': [7.5, 15, 22.5], 'BL': [15, 22.5, 30], 'VBL': [22.5, 30, 30]}
            }
        }
    }     


    
    distance_Member = {'VC': [0, 0, 2.5], 
                       'C':  [0, 2.5, 5],
                       'M': [2.5, 5, 7.5],
                       'F': [5, 7.5, 10], 
                       'VF': [7.5, 10, 10]}
    fuzzyDescription['inputs']['distance']['M'] = distance_Member

    angle_Member = {'BN': [-3.14, -3.14, -1.57], 
                    'N': [-3.14, -1.57, 0],
                    'Z': [-1.57, 0, 1.57], 
                    'P': [0, 1.57, 3.14], 
                    'BP': [1.57, 3.14, 3.14]}    
    fuzzyDescription['inputs']['angle']['M'] = angle_Member

    omegaR_Member =  {'VSR': [0, 0, 7.5], 
                      'SR': [7.5-CH[0], 7.5, 7.5+CH[1]],
                      'MBR': [7.5, 15, 22.5], 
                      'BR': [22.5-CH[2], 22.5, 22.5+CH[3]], 
                      'VBR': [22.5, 30, 30]}
    fuzzyDescription['outputs']['omegaR']['M'] = omegaR_Member

    omegaL_Member =  {'VSL': [0, 0, 7.5], 
                      'SL': [7.5-CH[4], 7.5, 7.5+CH[5]],
                      'MBL': [7.5, 15, 22.5], 
                      'BL': [22.5-CH[6], 22.5, 22.5+CH[7]], 
                      'VBL': [22.5, 30, 30]}
    fuzzyDescription['outputs']['omegaL']['M'] = omegaL_Member

    result['controllerParams']['fuzzyDescription'] = fuzzyDescription
    
    result['controllerParams']['r'] = result['robotParams']['r']
    result['controllerParams']['b'] = result['robotParams']['b']
    return result

"""#### Demo of Use"""

def localDemo():
    _chromosome = [ 6.25366018e-01,  1.46639889e+00,  6.86498991e-02,  7.68093084e-01,
  2.94696025e-01,  8.19657937e-01,  7.66707859e-01,  3.30363761e-01,
  1.59154795e+00,  3.82371835e-01,  3.19164222e-01,  2.25863186e-01,
  5.40214083e+00, -2.87811455e+00,  3.22315195e+00,  5.24697655e+00,
 -2.18191386e-02,  2.35114508e-02,  2.29313174e+00,  2.71500790e+00,
  1.72456119e+00,  3.34836959e+00,  1.62090031e+01,  2.21135246e+01,
  4.62340233e+00,  9.07996460e+00,  2.99889795e+01,  1.59696212e+01,
  1.20020626e+01,  2.32626634e+01,  1.81445098e+01,  1.61965141e+01,
  2.16820148e+01,  5.66692201e+00,  7.02338927e-01,  2.90220179e+00,
  1.46153727e+01,  1.93699985e+01,  1.47587643e+01,  6.76618158e+00,
  4.15791676e+00,  2.87105164e+01,  1.39444156e+01,  1.14641525e+01]

    #fuzzyLogicSimulationDescription = fromChromozomeToDescriptionFuzzy(_chromosome, simulationDescription)
    fuzzyLogicSimulationDescription = fromChromozomeToDescriptionFuzzy_Thoa(_chromosome, simulationDescription)
    results = runSimulation(fuzzyLogicSimulationDescription, createFuzzyController, selectors=selectors)

    plt.plot(results['x'], results['y'])
    
if _runDemos:
    localDemo()

"""## Path Mapping Function

This function allows to easy transform a data structure simulation description from path which a robot has to follow.
"""

import copy
def fromPathToDescription(path, description):
    result = copy.deepcopy(description)
    result['path'] = list(path)
    return result

"""## Fitness Functions (Based on Chromozomes)

For optimization a fitness function is needed. The simulation function has been defined earlier in this document. A fitness function must transform chromozome into simulation description, run appropriate simulation and return all results or a subset of results. This chapter defines a bunch of fitness functions suitable for a such task.

### Helper Functions

#### Function for Fitness Function Creation

```createFitnessFunction``` allows to create fitness function which is appropriate for description, chromosome decoder (```mapperFunction```), function which creates controller (```controllerCreator```) and, if needed, selection of subresult (```resultSelector```).
"""

def createFitnessFunction(baseDescription, mapperFunction, controllerCreator, resultSelector=lambda item: item):
    def fitnessFunction(chromozome):
        freshDescription = mapperFunction(chromozome, baseDescription)
        results = runSimulation(freshDescription, controllerCreator, selectors=selectors)
        result = resultSelector(results)
        return result
    return fitnessFunction

def energySelector(results):
    return results['E'][-1]

def distanceSelector(results):
    return results['d'][-1]

"""#### Multivalue Functions

```singleAsMultiValue``` transforms function with scalar value into function with vector value. Such transformation creates a functionc which can evaluate multiple values in single call.
"""

def singleAsMultiValue(singleFunction):
    def resultFunction(chromosomes):
        results = []
        for chromosome in chromosomes:
            results.append(singleFunction(chromosome))
        return results
    return resultFunction

"""### Simulation Description

From this point simulations depend on ```simulationDescription``` defined in next code. Thus if any change is needed this is best place for it.
"""

simulationDescription = {
    'robotState0': {
        'x': 0,
        'y': 0,
        'theta': -3.14 / 4
    },

    'path': [
        [0, 0, 0],  #X, Y, orientation
        [10, 0, 0], #X, Y, orientation
        [10, 10, 0], #X, Y, orientation
        [20, 10, 0], #X, Y, orientation
        [20, 20, 0]
    ],

    'robotParams': {
        'r': 0.0925,
        'b': 0.37,
        'm': 9,
        'I': 0.16245,
        #'motorParams': None,
        'motorParams': {
            'J': 0.01,
            'B': 0.1,

            'Kt': 0.01,
            'Ke': 0.01,
            'K': 0.01,

            'Ra': 0.1,
            'La': 0.01
        }
    },
    
    'controllerParams': {
        'omega_ri': 0, 'vri': 2.0,'lowVelocityLimit': 0.2, 
        'highVelocityLimit': 2.0, 'lowOmegaLimit': -0.75, 'highOmegaLimit': 0.75
    },

    'simulationParams': {
        't0': 0,
        't_bound': 100,
        'max_step': 0.05
    }
}

"""### Fuzzy Logic Controller

#### Singlevalue Functions
"""

fitnessFunctionFLC_Energy = createFitnessFunction(simulationDescription, fromChromozomeToDescriptionFuzzy, createFuzzyController, energySelector)
fitnessFunctionFLC_Distance = createFitnessFunction(simulationDescription, fromChromozomeToDescriptionFuzzy, createFuzzyController, distanceSelector)
fitnessFunctionFLC_FullResults = createFitnessFunction(simulationDescription, fromChromozomeToDescriptionFuzzy, createFuzzyController)

def localDemo(simulationDescription=simulationDescription):   
    
    chromosome = [2.5,2.5,2.5,2.5,2.5,5,2.5,2.5,7.5,2.5,2.5,  1.57,1.57,-1.57,1.57,1.57,0,1.57,1.57,1.57,1.57,1.57,  
                    7.5,7.5,7.5,7.5,7.5,15,7.5,7.5,22.5,7.5,7.5,  7.5,7.5,7.5,7.5,7.5,15,7.5,7.5,22.5,7.5,7.5]
    simulationDescription = fromChromozomeToDescriptionFuzzy(chromosome, simulationDescription)
    results = fitnessFunctionFLC_FullResults(chromosome)
    plt.plot(results['x'], results['y'])
    
if _runDemos:
    localDemo()

"""#### Multivalue Functions"""

fitnessFunctionFLC_EnergyMulti = singleAsMultiValue(fitnessFunctionFLC_Energy)
fitnessFunctionFLC_DistanceMulti = singleAsMultiValue(fitnessFunctionFLC_Distance)
fitnessFunctionFLC_FullResultsMulti = singleAsMultiValue(fitnessFunctionFLC_FullResults)

"""### Circle

#### Singlevalue Functions
"""

fitnessFunctionCircle_Energy = createFitnessFunction(simulationDescription, fromChromozomeToDescriptionCircle, createCircleControllerWithGain, energySelector)
fitnessFunctionCircle_Distance = createFitnessFunction(simulationDescription, fromChromozomeToDescriptionCircle, createCircleControllerWithGain, distanceSelector)
fitnessFunctionCircle_FullResults = createFitnessFunction(simulationDescription, fromChromozomeToDescriptionCircle, createCircleControllerWithGain)

"""#### Multivalue Functions"""

fitnessFunctionCircle_EnergyMulti = singleAsMultiValue(fitnessFunctionCircle_Energy)
fitnessFunctionCircle_DistanceMulti = singleAsMultiValue(fitnessFunctionCircle_Distance)
fitnessFunctionCircle_FullResultsMulti = singleAsMultiValue(fitnessFunctionCircle_FullResults)

"""#### Demonstration"""

def localDemo():
    results = fitnessFunctionCircle_FullResults([4])
    plt.plot(results['x'], results['y'])
    
if _runDemos:
    localDemo()

def localDemo():
    results = fitnessFunctionCircle_FullResultsMulti([[2], [16]])
    plt.plot(results[0]['x'], results[0]['y'])
    plt.plot(results[1]['x'], results[1]['y'])
    
if _runDemos:
    localDemo()

"""### Robins

#### Singlevalue Functions
"""

fitnessFunctionRobins_Energy = createFitnessFunction(simulationDescription, fromChromozomeToDescriptionCircle, createCircleControllerWithGain, energySelector)
fitnessFunctionRobins_Distance = createFitnessFunction(simulationDescription, fromChromozomeToDescriptionCircle, createCircleControllerWithGain, distanceSelector)
fitnessFunctionRobins_FullResults = createFitnessFunction(simulationDescription, fromChromozomeToDescriptionCircle, createCircleControllerWithGain)

"""#### Multivalue Functions"""

fitnessFunctionRobins_EnergyMulti = singleAsMultiValue(fitnessFunctionRobins_Energy)
fitnessFunctionRobins_DistanceMulti = singleAsMultiValue(fitnessFunctionRobins_Distance)
fitnessFunctionRobins_FullResultsMulti = singleAsMultiValue(fitnessFunctionRobins_FullResults)

"""## Computer Cluster Help

Multivalue fitness function is function which takes an array of chromozomes and returns another array containing the fitness values for all given chromozomes. Body of a such function could be implemented as a parallel process which decrease time needed for its evaluation.

The parallel process might be implemented in different ways. One of them, and probably the best one, is usage of distributed evaluation with help of computer cluster. Computer cluster creation is well-documented process with standard steps, thus, a scientist who want to use this technique must just define single environment, environment for evaluation of single fitness function. When you are running a computer cluster be sure that timeouts are defined appropriate. Simulation could need a couple of seconds and the balancer should be configured for it. There is not any backup for situation when the request is timed out.

As an envelope around this environment the web service might be used. However, this leads to asynchronous execution. As the optimization libraries for Python are synchronous, the connection between asynchronous and synchronous parts must be created.

### Main Function for Server

```evaluateSingleFLCSimulation``` is function which could be used for a webservice which transforms incomming document into simulation results.
"""

def evaluateSingleFLCSimulation(description):
    results = runSimulation(description, createFuzzyController, selectors)
    return results

def localDemo():
    simulationDescription = {
        'robotState0': {
            'x': 0,
            'y': 0,
            'theta': -3.14 / 4
        },

        'path': [
            [0, 0, 0],  #X, Y, orientation
            [10, 0, 0], #X, Y, orientation
            [10, 10, 0], #X, Y, orientation
            [20, 10, 0], #X, Y, orientation
            [20, 20, 0]
        ],

        'robotParams': {
            'r': 0.0925,
            'b': 0.37,
            'm': 9,
            'I': 0.16245,
            #'motorParams': None,
            'motorParams': {
                'J': 0.01,
                'B': 0.1,

                'Kt': 0.01,
                'Ke': 0.01,
                'K': 0.01,

                'Ra': 0.1,
                'La': 0.01
            }
        },

        'controllerParams': {
            'omega_ri': 0, 'vri': 2.0,'lowVelocityLimit': 0.2, 
            'highVelocityLimit': 2.0, 'lowOmegaLimit': -0.75, 'highOmegaLimit': 0.75
        },

        'simulationParams': {
            't0': 0,
            't_bound': 100,
            'max_step': 0.05
        }
    }    
    chromosome = [2.5,2.5,2.5,2.5,2.5,5,2.5,2.5,7.5,2.5,2.5,  1.57,1.57,-1.57,1.57,1.57,0,1.57,1.57,1.57,1.57,1.57,  
                    7.5,7.5,7.5,7.5,7.5,15,7.5,7.5,22.5,7.5,7.5,  7.5,7.5,7.5,7.5,7.5,15,7.5,7.5,22.5,7.5,7.5]
    chromosome = [1.65489766e+00,  4.71772317e-01,  2.11355940e+00,  7.79405677e+00,
  3.90133893e-01,  4.54154522e+00,  3.92191115e+00,  9.87151136e+00,
  7.01405501e+00,  2.94723419e+00,  8.65770886e+00,  5.43661045e-01,
  4.74421363e+00, -2.22945187e+00,  2.90250771e+00,  2.83345131e+00,
 -9.46880441e-01,  3.15894734e-03,  9.69445602e-01,  1.26720603e+00,
  4.80998234e+00,  4.78282650e+00,  1.02884530e+01,  2.75044477e+01,
  1.87236346e+00,  1.56593237e+01,  1.62036786e+01,  1.79087622e+01,
  1.67324219e+01,  1.72954035e+01,  2.58453260e+01,  1.04102732e+01,
  7.05820148e+00,  5.74866057e+00,  2.84084449e+01,  6.66375272e+00,
  1.63284852e+01,  2.57865307e+01,  1.67465610e+01,  2.62379666e+00,
  4.78348127e+00,  1.82410692e+01,  2.58783546e+01,  1.37510949e+01]

    description = fromChromozomeToDescriptionFuzzy(chromosome, simulationDescription)    
    
    results = evaluateSingleFLCSimulation(description)
    plt.plot(results['x'], results['y'])
    
if _runDemos:
   localDemo()

"""### Async as Sync

For ability to evaluate set of simulations in parallel async functions should be used and maintaned. For optimization algorithms this must be callable from synchronous environment and thus a conversion from async to sync must be done. This part of code has been taken from https://stackoverflow.com/questions/49330905/how-to-run-a-coroutine-and-wait-it-result-from-a-sync-func-when-the-loop-is-runn
"""

import asyncio
import threading
#----------------------------------------
# upgraded from https://stackoverflow.com/questions/49330905/how-to-run-a-coroutine-and-wait-it-result-from-a-sync-func-when-the-loop-is-runn
#----------------------------------------

def evalSet(asyncTask, values):
    loop = asyncio.new_event_loop() # construct a new event loop

    def run_forever_safe(loop):
        loop.run_forever()
        # for Python 3.7 and newer
        # loop_tasks_all = asyncio.all_tasks(loop=loop)
        # for Python 3.6
        loop_tasks_all = asyncio.Task.all_tasks(loop=loop)

        for task in loop_tasks_all: 
            task.cancel()

        for task in loop_tasks_all:
            if not (task.done() or task.cancelled()):
                try:
                    # wait for task cancellations
                    loop.run_until_complete(task)
                except asyncio.CancelledError: pass

        loop.close()
    
    def stop_loop(loop):
        ''' stops an event loop '''
        loop.stop()
        #print (".:) LOOP STOPPED:", loop.is_running())
        
    def await_sync(task):
        ''' synchronously waits for a task '''
        while not task.done(): 
            pass
        #print(".: AWAITED TASK DONE")
        return task.result()
    
    #-- closures for running and stopping the event-loop
    run_loop_forever = lambda: run_forever_safe(loop)
    close_loop_safe = lambda: loop.call_soon_threadsafe(stop_loop, loop)
    
    #-- make dedicated thread for running the event loop
    thread = threading.Thread(target=run_loop_forever)

    #-- add some tasks along with my particular task
    evaluationTasks = [asyncio.run_coroutine_threadsafe(asyncTask(value), loop=loop) for value in values]

    #-- begin the thread to run the event-loop
    thread.start()

    #-- _synchronously_ wait for the result of my task
    results = [await_sync(task) for task in evaluationTasks]

    # close the loop gracefully when everything is finished
    close_loop_safe()
    thread.join()
    return results
#----------------------------------------

"""### Webservice Usage"""

!pip install aiohttp

import time
def mS(start = 0):
    return int(round(time.time() * 1000)) - start

"""This part encapsules a remote fitness function evaluator. Parameter describes fully the simulation thus a remote evaluator does not make any conversion, just run the described simulation and returns the results.

This function is crucial in use of computer cluster on client side. Also this is a point where the evaluation could be redirected to proper sources.
"""

import aiohttp
import asyncio

#url = 'https://ourserver/api/evaluator/FFFF' # you must replace our URL address (which was unable to run) with your one.

async def fitnessFunctionAsWebservice(value):
    #async with aiohttp.ClientSession() as session:
    async with aiohttp.ClientSession(connector=aiohttp.TCPConnector(ssl=False)) as session:
        response = await session.post(url, json=value, headers = {'content-type': 'application/x-json'})
        try:
            json_body = await response.json()
        except:
            rtext = await response.text()
            print(rtext)
    return json_body

async def localDemo():
    
    simulationDescription = {
        'robotState0': {
            'x': 0,
            'y': 0,
            'theta': -3.14 / 4
        },

        'path': [
            [0, 0, 0],  #X, Y, orientation
            [10, 0, 0], #X, Y, orientation
            [10, 10, 0], #X, Y, orientation
            [20, 10, 0], #X, Y, orientation
            [20, 20, 0]
        ],

        'robotParams': {
            'r': 0.0925,
            'b': 0.37,
            'm': 9,
            'I': 0.16245,
            #'motorParams': None,
            'motorParams': {
                'J': 0.01,
                'B': 0.1,

                'Kt': 0.01,
                'Ke': 0.01,
                'K': 0.01,

                'Ra': 0.1,
                'La': 0.01
            }
        },

        'controllerParams': {
            'omega_ri': 0, 'vri': 2.0,'lowVelocityLimit': 0.2, 
            'highVelocityLimit': 2.0, 'lowOmegaLimit': -0.75, 'highOmegaLimit': 0.75
        },

        'simulationParams': {
            't0': 0,
            't_bound': 100,
            'max_step': 0.05
        }
    }    
    chromosome = [2.5,2.5,2.5,2.5,2.5,5,2.5,2.5,7.5,2.5,2.5,  1.57,1.57,-1.57,1.57,1.57,0,1.57,1.57,1.57,1.57,1.57,  
                    7.5,7.5,7.5,7.5,7.5,15,7.5,7.5,22.5,7.5,7.5,  7.5,7.5,7.5,7.5,7.5,15,7.5,7.5,22.5,7.5,7.5]
    webServiceSimulationDescription = fromChromozomeToDescriptionFuzzy(chromosome, simulationDescription)
    #print(webServiceSimulationDescription)
    async with aiohttp.ClientSession(connector=aiohttp.TCPConnector(ssl=False)) as session:
        response = await session.post(url, json=webServiceSimulationDescription, headers = {'content-type': 'application/x-json'})
        data = await response.text()
        print(data[:1024])
        
if _runDemos:        
  localDemo()

def callResultsFLC():
    sTime = mS()        
    results = evalSet(fitnessFunctionAsWebservice, [fitnessFunctionDescription])
    return results

"""### Remote / Cluster Fitness Function Evaluation

This function is the real "sibling" of other fitness functions introduced earlier. However, this function transforms chromosomes into simulation descriptions and send them for evaluation to a computer cluster. Results received from the computer cluster are json decoded and returned.
"""

import copy
def fitnessFunctionFLC_FullMultiRemote(chromosomes):

    descriptions = []

    for chromosome in chromosomes:
        tempDescription = copy.deepcopy(simulationDescription)
        description = fromChromozomeToDescriptionFuzzy(chromosome, tempDescription)
        descriptions.append(description)

    # Pythonic way:
    # descriptions = [fromChromozomeToDescriptionFuzzy(chromosome, simulationDescription) for chromosome in chromosomes]
        
    results = evalSet(fitnessFunctionAsWebservice, descriptions)
    return results

'''
def localDemo():
    if useCluster:
        chromosome = [2.5,2.5,2.5,2.5,2.5,5,2.5,2.5,7.5,2.5,2.5,  1.57,1.57,-1.57,1.57,1.57,0,1.57,1.57,1.57,1.57,1.57,  
                        7.5,7.5,7.5,7.5,7.5,15,7.5,7.5,22.5,7.5,7.5,  7.5,7.5,7.5,7.5,7.5,15,7.5,7.5,22.5,7.5,7.5]
        results = fitnessFunctionFLC_FullMultiRemote([chromosome, chromosome])
        
        plt.plot(results[0]['time'], results[0]['x'])
        plt.plot(results[1]['time'], results[1]['y'])
        pass

if _runDemos:
    localDemo()
'''

def fitnessFunctionFLC_EnergyMultiRemote(chromosomes):
    results = fitnessFunctionFLC_FullMultiRemote(chromosomes)
    
    selectedResults = []
    for result in results:
        selectedResults.append(result['E'])

    # Pythonic way:
    # selectedResults = [result['E'] for result in results]

    return selectedResults

def fitnessFunctionFLC_DistanceMultiRemote(chromosomes):
    results = fitnessFunctionFLC_FullMultiRemote(chromosomes)

    selectedResults = []
    for result in results:
        selectedResults.append(result['E'])
    return selectedResults

"""### Decision about Cluster Use

This part ovewrites definitions of fitness functions evaluating simulation with use of fuzzy logic controller.
"""

#if useCluster:
#    fitnessFunctionFLC_EnergyMulti = fitnessFunctionFLC_EnergyMultiRemote#singleAsMultiValue(fitnessFunctionFLC_Energy)
#    fitnessFunctionFLC_DistanceMulti = fitnessFunctionFLC_DistanceMultiRemote#singleAsMultiValue(fitnessFunctionFLC_Distance)
#    fitnessFunctionFLC_FullResultsMulti = fitnessFunctionFLC_FullMultiRemote#singleAsMultiValue(fitnessFunctionFLC_FullResults)  
#    pass

"""## Optimization

In previous chapters the simulation has been implemented, also different transformation functions have been introduced. From them a couple of fitness function has been declared. For the optimizaton task just an optimization algorithm is needed. For this stage the [pymoo library](https://pymoo.org/) has been chosen.

### Inevitable Imports
"""

!pip install pymoo

pip install -U pymoo

import time
#from pymoo.algorithms.so_genetic_algorithm import GA (Old version 0.4.2)
from pymoo.algorithms.soo.nonconvex.ga import GA
from pymoo.factory import get_sampling, get_crossover, get_mutation
#from pymoo.model.problem import Problem
from pymoo.core.problem import Problem # for new version (0.5.0)
from pymoo.optimize import minimize
from pymoo.factory import get_termination
from pymoo.visualization.scatter import Scatter

"""### Formal Problem Description"""

simulationDescription = {
    'robotState0': {
        'x': 0,
        'y': 0,
        'theta': -3.14 / 4
    },

    'path':[
        [0, 0, 0],  #X, Y, orientation
        [10, 0, 0], #X, Y, orientation
        [10, 10, 0], #X, Y, orientation
        [20, 10, 0], #X, Y, orientation
        [20, 20, 0]
    ],

    'robotParams': {
        'r': 0.0925,
        'b': 0.37,
        'm': 9,
        'I': 0.16245,
        #'motorParams': None,
        'motorParams': {
            'J': 0.01,
            'B': 0.1,

            'Kt': 0.01,
            'Ke': 0.01,
            'K': 0.01,

            'Ra': 0.1,
            'La': 0.01
        }
    },

    'controllerParams': {
        'omega_ri': 0, 'vri': 2.0,'lowVelocityLimit': 0.2, 
        'highVelocityLimit': 2.0, 'lowOmegaLimit': -0.75, 'highOmegaLimit': 0.75
    },

    'simulationParams': {
        't0': 0,
        't_bound': 100,
        'max_step': 0.05
    }
}    

# The GA In this experiment, each population has many chromosomes. Each chromosome has 44 gens. These gens are responsible for the parameters of the membership functions of the FLC
# The values of this parameter have been chosen in a range of [chromosomeFLCLow, chromosomeFLCUp] randomly.
# In this experiment, based on the structure of the FLC, authors have chosen the chromosomeFLCLow and chromosomeFLCUp as below:
# chromosomeFLCLow = [0,  0,  0, 0, 0,2.6, 0, 0,7.6, 0, 0,   0,      0,-3.14,   0,   0,-1,   0,   0,   1,   0,   0    0, 0, 0, 0, 0, 12,0, 0, 18, 0, 0,    0, 0, 0, 0, 0, 12, 0, 0,18,0, 0 ]
# chromosomeFLCUp =  [10,10,2.5,10,10,7.5,10,10,10, 10,10,   6.28,6.28,   -1,6.28,6.28, 1,6.28,6.28,3.14,6.28,6.28    30,30,12,30,30,18,30,30,30,30,30,    30,30,12,30,30,18,30,30,30,30,30]

problemParametersSetA = [0, 0, 0, 0, 0,  2.6, 0, 0,  7.6, 0, 0,    0, 0, -3.14, 0, 0, -1,  0, 0, 1,  0, 0]
problemParametersSetB = [0, 0, 0, 0, 0, 12, 0, 0, 18, 0, 0,        0, 0,  0,    0, 0,  12, 0, 0, 18, 0, 0]
chromosomeFLCLow = [*problemParametersSetA, *problemParametersSetB]

problemParametersSetC = [10, 10, 2.5, 10, 10, 7.5, 10,10,10,10,10,           6.28, 6.28, -1, 6.28, 6.28, 1,  6.28, 6.28, 3.14, 6.28, 6.28]
problemParametersSetD = [30,30, 12,   30, 30, 18,   30, 30, 30, 30, 30,      30,   30,   12, 30,   30,   18, 30,   30,   30,   30,   30]
chromosomeFLCUp = [*problemParametersSetC, *problemParametersSetD]

class MyProblem(Problem):
    def __init__(self):
        self.SpecialCounter = 0
        super().__init__(
            n_var=44, n_obj=1, n_constr=1,
            xl=np.array([*problemParametersSetA, *problemParametersSetB]),
            xu=np.array([*problemParametersSetC, *problemParametersSetD]),
            ElementwiseProblem=False)
        
    def _evaluate(self, Chromosome, out, *args, **kwargs):
        if useCluster:
            #allResults = fitnessFunctionFLC_FullMultiRemote(Chromosome)
            descriptions = [fromChromozomeToDescriptionFuzzy(ch, description=simulationDescription) for ch in Chromosome]
            allResults = evalSet(fitnessFunctionAsWebservice, descriptions)
        else:
            allResults = [fitnessFunctionFLC_FullResults(ch) for ch in Chromosome]
            #allResults = fitnessFunctionFLC_FullResultsMulti(Chromosome)
        f1 = np.array([energySelector(result) for result in allResults]) # used to evaluate the energy consumption
        #f1 = np.array([distanceSelector(result) for result in allResults]) # used to evaluate the travel distance
        g1 = np.array([distanceSelector(result) - 50 for result in allResults]) # the constraint for tracking the zigzag path. Need to change value 50 when optimizing a different path.

        out["F"] = f1
        out["G"] = g1
        #print(len(Chromosome), '|', end='')

'''
# Use for Mohammadian-based controller
simulationDescription = {
    'robotState0': {
        'x': 0,
        'y': 0,
        'theta': 3.14 / 4
    },

    'path': [
        [0, 0, 0],  #X, Y, orientation
        [0.1, 0, 0], #X, Y, orientation
        [0, 0.1, 0], #X, Y, orientation
        [0.1, 0.1, 0], #X, Y, orientation
        [0, 0.2, 0]
    ],

    'robotParams': {
        'r': 0.0925,
        'b': 0.37,
        'm': 9,
        'I': 0.16245,
        #'motorParams': None,
        'motorParams': {
            'J': 0.01,
            'B': 0.1,

            'Kt': 0.01,
            'Ke': 0.01,
            'K': 0.01,

            'Ra': 0.1,
            'La': 0.01
        }
    },

    'controllerParams': {
        'omega_ri': 0, 'vri': 2.0,'lowVelocityLimit': 0.2, 
        'highVelocityLimit': 2.0, 'lowOmegaLimit': -0.75, 'highOmegaLimit': 0.75
    },

    'simulationParams': {
        't0': 0,
        't_bound': 100,
        'max_step': 0.05
    }
}    

# The GA In this experiment, each population has many chromosomes. Each chromosome has 44 gens. These gens are responsible for the parameters of the membership functions of the FLC
# The values of this parameter have been chosen in a range of [chromosomeFLCLow, chromosomeFLCUp] randomly.
# In this experiment, based on the structure of the FLC, authors have chosen the chromosomeFLCLow and chromosomeFLCUp as below:
# chromosomeFLCLow = [0,  0,  0, 0, 0,2.6, 0, 0,7.6, 0, 0,   0,      0,-3.14,   0,   0,-1,   0,   0,   1,   0,   0    0, 0, 0, 0, 0, 12,0, 0, 18, 0, 0,    0, 0, 0, 0, 0, 12, 0, 0,18,0, 0 ]
# chromosomeFLCUp =  [10,10,2.5,10,10,7.5,10,10,10, 10,10,   6.28,6.28,   -1,6.28,6.28, 1,6.28,6.28,3.14,6.28,6.28    30,30,12,30,30,18,30,30,30,30,30,    30,30,12,30,30,18,30,30,30,30,30]

problemParametersSetA = [1, 1, 1, 1]
problemParametersSetB = [1, 1, 1, 1]
chromosomeFLCLow = [*problemParametersSetA, *problemParametersSetB]

problemParametersSetC = [7.5, 7.5, 7.5, 7.5]
problemParametersSetD = [7.5, 7.5, 7.5, 7.5]
chromosomeFLCUp = [*problemParametersSetC, *problemParametersSetD]

class MyProblem(Problem):
    def __init__(self):
        self.SpecialCounter = 0
        super().__init__(
            n_var=8, n_obj=1, n_constr=1,
            xl=np.array([*problemParametersSetA, *problemParametersSetB]),
            xu=np.array([*problemParametersSetC, *problemParametersSetD]),
            ElementwiseProblem=False)
        
    def _evaluate(self, Chromosome, out, *args, **kwargs):
        if useCluster:
            #allResults = fitnessFunctionFLC_FullMultiRemote(Chromosome)
            descriptions = [fromChromozomeToDescriptionFuzzy_Mohammadian(ch, description=simulationDescription) for ch in Chromosome]
            allResults = evalSet(fitnessFunctionAsWebservice, descriptions)
        else:
            allResults = [fitnessFunctionFLC_FullResults(ch) for ch in Chromosome]
            #allResults = fitnessFunctionFLC_FullResultsMulti(Chromosome)
        f1 = np.array([energySelector(result) for result in allResults]) # used to evaluate the energy consumption
        #f1 = np.array([distanceSelector(result) for result in allResults]) # used to evaluate the travel distance
        g1 = np.array([distanceSelector(result) - 50 for result in allResults]) # the constraint for tracking the zigzag path. Need to change value 50 when optimizing a different path.

        out["F"] = f1
        out["G"] = g1
        #print(len(Chromosome), '|', end='')
'''

"""### Optimization Problem Solution"""

start_time = time.time()
problem = MyProblem()

algorithm = GA(
    pop_size=50,
    eliminate_duplicates=True)

termination = get_termination("n_gen",200)

print('Going to optimize with use of movement along this path:', simulationDescription['path'])

res = minimize(problem,
               algorithm,
               termination,
               seed=1,
               save_history=True,
               verbose=True)

print(f'After {res.exec_time} s the algorithm finished')
print(f'A solution \n{res.X}\n was found')
print(f'The suboptimal value of fitness function is \t {res.F}')
Best_Chromosome = res.X

"""## Results Analysys

### Optimal value over generation
"""

plt.rcParams["figure.figsize"] = (12, 8)
plt.rcParams["font.size"] = "18"


#ret = [np.min(e.pop.get("F")) for e in res.history]

ret = [6.65016E+01, 6.65016E+01, 3.78875E+01, 3.78875E+01, 3.37551E+01, 2.77923E+01, 2.77923E+01, 2.58299E+01, 2.58299E+01, 1.78978E+01,1.53562E+01, 1.53562E+01, 1.53562E+01, 1.53562E+01,  1.53562E+01, 1.53562E+01, 
   1.51949E+01, 1.34387E+01, 1.34387E+01, 1.34387E+01, 1.29566E+01, 1.18987E+01, 1.18987E+01, 1.18095E+01, 1.05584E+01, 1.05584E+01, 1.05584E+01, 
   1.02236E+01, 1.02236E+01, 1.01547E+01, 9.847593812, 9.813466870, 9.813466870, 9.813466870, 9.779430890, 9.642956527, 9.642956527, 9.642956527, 9.633666327, 
   9.280703892, 9.280703892, 9.280703892, 8.933943872, 8.913644514, 8.702565010, 8.644024565, 8.644024565, 8.644024565, 8.642331089, 8.642331089, 8.598003578, 
   8.598003578, 8.598003578, 8.598003578, 8.587602976, 8.587602976, 8.585731565, 8.585731565, 8.585357797, 8.580099287, 8.580099287, 8.579024852, 8.579024852, 
   8.577800577, 8.577399114, 8.573082629, 8.573082629, 8.573082629, 8.573054864, 8.571264073, 8.571196994, 8.571196994, 8.567951117, 8.567951117, 8.564503226, 
   8.564503226, 8.549275951, 8.546012357, 8.544338076, 8.532171425, 8.532171425, 8.526543369, 8.525505769, 8.523644063, 8.523644063, 8.521533975, 8.520114759, 
   8.519765475, 8.516186931, 8.516116057, 8.514484528, 8.514047470, 8.514047470, 8.513589750, 8.513589750, 8.512869639, 8.511959107, 8.511758394, 8.510663172, 
  8.510663172, 8.510194971, 8.509814814, 8.509442941, 8.509442941, 8.509442941, 8.509339672, 8.508718907, 8.508671023, 8.508671023, 8.507909897, 8.507909897, 
  8.507718067, 8.507445171, 8.507445171, 8.507445171, 8.506855916, 8.506855916, 8.506855916, 8.502494405, 8.502494405, 8.502494405, 8.502494405, 8.502494405, 
  8.501360183, 8.500985670, 8.500980001, 8.500980001, 8.499211749, 8.499058726, 8.498832294, 8.498832294, 8.498792152, 8.497946356, 8.497946356, 8.497508122, 
  8.497414615, 8.497414615, 8.497414615, 8.497414615, 8.497414615, 8.497352229, 8.497352229, 8.497332710, 8.497301052, 8.495359133, 8.495350415, 8.495206020, 
  8.495206020, 8.495201620, 8.494461838, 8.494460180, 8.494263590, 8.494263590, 8.494045573, 8.494037118, 8.494014061, 8.493937511, 8.493932243, 8.493884989, 
  8.493884989, 8.493884989, 8.493884989, 8.493848304, 8.493848304, 8.493822168, 8.493784881, 8.493744626, 8.493716801, 8.493716801, 8.493716801, 8.493701872, 
  8.493701872, 8.493699786, 8.493699786, 8.493698803, 8.493697536, 8.493696241, 8.493696241, 8.493076014, 8.493075660, 8.493071910, 8.489287448, 8.489287448, 
  8.489287448, 8.489270022, 8.489258657, 8.488760821, 8.488400179, 8.488298523, 8.488221396,8.488221396,8.488221396,8.488221396,8.488221396,8.488221396,8.488221396,
  8.488221396,8.488221396,8.488221396,8.488221396] 


plt.plot(np.arange(len(ret)), ret, 'b-', lw=3)
plt.title("Convergence")
plt.xlabel("Generation")
plt.ylabel("Optimal value")
plt.legend()
plt.show()

"""### Selectors Reintroduction"""

selectx = lambda item: item['y'][0]       # x position
selecty = lambda item: item['y'][1]       # y position
selectt = lambda item: item['time']       # time
selectv = lambda item: item['dy'][3]      # velocity
selectomega = lambda item: item['dy'][2]  # omega = theta_dot
selecte = lambda item: item['TotalEnergy']# total energy
selects = lambda item: item['y'][3]       # displacement
selectors = {
    'time': selectt,
    'x': selectx, 
    'y': selecty, 
    'd': selects, 
    'v': selectv, 
    'omega': selectomega,
    'E': selecte}

"""### Comparative Simulations"""

# Using the "Best_Chromosome" here to get results of optimal FLC. Remove it when finishing.

Best_Chromosome =  [ 3.67124875e+00,  1.10410556e+00,  1.87733267e+00,  9.58325181e+00,
  2.53733116e+00,  3.38894300e+00,  3.80725896e+00,  8.63259729e+00,
  8.75637290e+00,  7.33995805e+00,  7.24795725e+00,  1.52387688e-02,
  6.08969059e+00, -2.67188966e+00,  3.57545145e+00,  1.16755674e-02,
 -5.96131673e-01,  1.98935658e-02,  3.86391460e+00,  3.13698965e+00,
  3.01054404e+00,  4.43728554e+00,  2.86623698e+01,  1.07336250e+01,
  3.97423515e+00,  1.51395951e+01,  2.06035264e+01,  1.33091875e+01,
  1.41078659e-04,  1.32398779e+01,  2.04415703e+01,  1.09482986e+01,
  5.50099503e+00,  5.80793062e+00,  2.56325715e+01,  1.06872884e+01,
  1.12408747e+01,  3.75566216e-01,  1.20798289e+01,  4.55074728e+00,
  1.08970815e+01,  2.22721497e+01,  2.65501820e+01,  2.04000412e+01]

# FLCChromosome use to get values of original FLC
FLCChromosome = [2.5,2.5,2.5,2.5,2.5,5,2.5,2.5,7.5,2.5,2.5,  1.57,1.57,-1.57,1.57,1.57,0,1.57,1.57,1.57,1.57,1.57,  
                    7.5,7.5,7.5,7.5,7.5,15,7.5,7.5,22.5,7.5,7.5,  7.5,7.5,7.5,7.5,7.5,15,7.5,7.5,22.5,7.5,7.5]
FuzzyOriginalChromosome = FLCChromosome

ExpertChromosome = [1,1,1,1,1,2,1,1,3,2,2,5,2,2,7,3,3,   1.57,1.57,-1.57,0.785,0.785,-0.785,0.785,0.785,0,0.785,0.785,0.785,0.785,0.785,1.57,1.57,1.57,
                    5,5,5,5,5,10,5,5,15,5,5,20,5,5,25,5,5,   5,5,5,5,5,10,5,5,15,5,5,20,5,5,25,5,5]

MohammadianChromosome = [7.48419025, 6.05502005, 7.5, 1, 7.49917806, 7.5, 7.5, 1 ]

# Waypoints tracking
if Waypoint:
  path = [
          [0, 0, 0],  #X, Y, orientation
          [10, 0, 0], #X, Y, orientation
          [10, 10, 0], #X, Y, orientation
          [20, 10, 0], #X, Y, orientation
          [20, 20, 0]
      ]

# Trajectory tracking
#Number eight sharp
if Number8:
  path_x = None
  path_y = None
  path_theta = 0
  path=[]
  x_path = []
  y_path = []
  for time in range(0,61):
    omegaR = 3.14/30
    x_p = 2 + 10*sin(omegaR*time)
    y_p = 1 + 5*sin(2*omegaR*time)
    x_path.append(x_p)
    y_path.append(y_p)
    path_x = x_p
    path_y = y_p
    path_theta = 0
    path1 = [path_x, path_y, path_theta]
    path.append(path1)
  #path = path

# Circle path
if Circle: 
  path_x = None
  path_y = None
  path_theta = 0
  path=[]
  x_path = []
  y_path = []
  for time in range(0,61):
    omegaR = 3.14/30
    #theta = np.linspace( 0 , 2 * np.pi , 150 )
    radius = 8
    x_p = -8 + radius * np.cos(omegaR*time)
    y_p = 4 + radius * np.sin(omegaR*time)
    x_path.append(x_p)
    y_path.append(y_p)
    path_x = x_p
    path_y = y_p
    path_theta = 0
    path1 = [path_x, path_y, path_theta]
    path.append(path1)

pathX = [point[0] for point in path]
pathY = [point[1] for point in path]

# simulationDescription updated to path
simulationDescription = fromPathToDescription(path, simulationDescription)
simulationDescription['simulationParams']['t_bound'] = 50

# descriptions for simulations
FuzzyOriginalSimDescription = fromChromozomeToDescriptionFuzzy(FuzzyOriginalChromosome, simulationDescription)
FLCSimDescription = fromChromozomeToDescriptionFuzzy(Best_Chromosome, simulationDescription)
RobinDescription = fromChromozomeToDescriptionRobins([1.51, 45.84], simulationDescription)
CircleDescription = fromChromozomeToDescriptionCircle([4], simulationDescription)
ChaudhariDescription = fromChromozomeToDescriptionChaudhari([0.1], simulationDescription)
ThoaFLCSimDescription = fromChromozomeToDescriptionFuzzy_Thoa(FuzzyOriginalChromosome, simulationDescription)
ExpertFLCSimDescription = fromChromozomeToDescriptionFuzzy_Expert(ExpertChromosome, simulationDescription)
MohammadianSimDescription = fromChromozomeToDescriptionFuzzy_Mohammadian(MohammadianChromosome, simulationDescription)

FLCFullResults = runSimulation(FLCSimDescription, createFuzzyController, selectors=selectors)
FuzzyOriginalResults = runSimulation(FuzzyOriginalSimDescription, createFuzzyController, selectors=selectors)
RobinFullResults = runSimulation(RobinDescription, createController_By_RobinsMathew, selectors=selectors)
CircleFullResults = runSimulation(CircleDescription, createCircleControllerWithGain, selectors=selectors)
ChaudhariFullResults = runSimulation(ChaudhariDescription, createChaudhariController, selectors=selectors)
ThoaFullResults = runSimulation(ThoaFLCSimDescription, createFuzzyController, selectors=selectors)
ExpertFullResults = runSimulation(ExpertFLCSimDescription, createFuzzyController, selectors=selectors)
MohammadianFullResults = runSimulation(MohammadianSimDescription, createFuzzyController, selectors=selectors)

"""### Results Plots"""

plt.rcParams["figure.figsize"] = (30, 30)
plt.rcParams["font.size"] = "14"

def multiPlot(xs, ys, styles, labels,lws):
    for x, y, style, label,lw in zip(xs, ys, styles, labels,lws):
        plt.plot(x, y, style, label=label, lw=lw)

#--plot the path--------------------------------------------------------------
plt.subplot(3, 2, 1)
plt.grid(which = 'both') 
p = plt.axis('equal')
if Waypoint:
  multiPlot(
      [pathX, CircleFullResults['x'], RobinFullResults['x'], FLCFullResults['x'], ChaudhariFullResults['x'],ThoaFullResults['x'],ExpertFullResults['x'], MohammadianFullResults['x']],
      [pathY, CircleFullResults['y'], RobinFullResults['y'], FLCFullResults['y'], ChaudhariFullResults['y'],ThoaFullResults['y'],ExpertFullResults['y'], MohammadianFullResults['y']],
      ['b-', 'k--', 'b--', 'g-','r-','r:','g-.', 'k-.'],      
      ['Planned path', 'Circle controller', 'Mathew controller', 'GA_FLC controller', 'Chaudhari-based controller','Thoa-based controller','Expert-based controller','Mohammadian-FLC_GA'],
      [1,3,1,3,1,3,1,3],
      )
  plt.legend(loc = 'best')
  plt.xlabel('x(m)')
  plt.ylabel('y(m)')

  #--plot the distance--------------------------------------------------------------
  plt.subplot(3, 2, 2)
  plt.grid(which = 'both') 
  multiPlot(
      [CircleFullResults['time'], RobinFullResults['time'], FLCFullResults['time'], ChaudhariFullResults['time'],ThoaFullResults['time'], ExpertFullResults['time'], MohammadianFullResults['time']],
      [CircleFullResults['d'], RobinFullResults['d'], FLCFullResults['d'], ChaudhariFullResults['d'],ThoaFullResults['d'],ExpertFullResults['d'], MohammadianFullResults['d']],
      ['k--', 'b--', 'g-','r-','r:','g-.', 'k-.'],
      ['Circle controller', 'Mathew controller', 'GA_FLC controller', 'Chaudhari-based controller','Thoa-based controller','Expert-based controller', 'Mohammadian-FLC_GA'],
      [3,1,3,1,3,1,3],
      )
  plt.legend(loc = 'best')
  plt.xlabel('Time(s)')
  plt.ylabel('Travel distance (m)')

  #---plot the velocity----------------------------------------------------------
  plt.subplot(3, 2, 3)
  plt.grid(which = 'both') 
  multiPlot(
      [CircleFullResults['time'], RobinFullResults['time'], FLCFullResults['time'], ChaudhariFullResults['time'],ThoaFullResults['time'],ExpertFullResults['time'],MohammadianFullResults['time']],
      [CircleFullResults['v'], RobinFullResults['v'], FLCFullResults['v'], ChaudhariFullResults['v'],ThoaFullResults['v'],ExpertFullResults['v'],MohammadianFullResults['v']],
      ['k--', 'b--', 'g-','r-','r:','g-.', 'k-.'],
      ['Circle controller', 'Mathew controller', 'GA_FLC controller', 'Chaudhari-based controller','Thoa-based controller', 'Expert-based controller','Mohammadian-FLC_GA'],
      [3,1,3,1,3,1,3],
      )
  plt.legend(loc = 'lower left')
  plt.xlabel('Time(s)')
  plt.ylabel('Linear Velocity (m/s)')

  #--plot the omega-------------------------------------------------------------
  plt.subplot(3, 2, 4)
  plt.grid(which = 'both') 
  multiPlot(
      [CircleFullResults['time'], RobinFullResults['time'], FLCFullResults['time'], ChaudhariFullResults['time'],ThoaFullResults['time'],ExpertFullResults['time'],MohammadianFullResults['time']],
      [CircleFullResults['omega'], RobinFullResults['omega'], FLCFullResults['omega'], ChaudhariFullResults['omega'],ThoaFullResults['omega'],ExpertFullResults['omega'],MohammadianFullResults['omega']],
      ['k--', 'b--', 'g-','r-','r:','g-.', 'k-.'],
      ['Circle controller', 'Mathew controller', 'GA_FLC controller', 'Chaudhari-based controller','Thoa-based controller','Expert-based controller','Mohammadian-FLC_GA'],
      [3,1,3,1,3,1,3],
      )
  plt.legend(loc = 'lower right')
  plt.xlabel('Time(s)')
  plt.ylabel('Angular velocity (rad/s)')

  #--plot the total energy consumption------------------------------------------
  plt.subplot(3, 2, 5)
  plt.grid(which = 'both') 
  multiPlot(
      [CircleFullResults['time'], RobinFullResults['time'], FLCFullResults['time'], ChaudhariFullResults['time'],ThoaFullResults['time'],ExpertFullResults['time'],MohammadianFullResults['time']],
      [CircleFullResults['E'], RobinFullResults['E'], FLCFullResults['E'], ChaudhariFullResults['E'],ThoaFullResults['E'],ExpertFullResults['E'],MohammadianFullResults['E']],
      ['k--', 'b--', 'g-','r-','r:','g-.', 'k-.'],
      ['Circle controller', 'Mathew controller', 'GA_FLC controller','Chaudhari-based controller','Thoa-based controller','Expert-based controller','Mohammadian-FLC_GA'],
      [3,1,3,1,3,1,3],
      )
  plt.legend(loc = 'lower right')
  plt.xlabel('Time(s)')
  plt.ylabel('Energy consumption ( J )')

  #------------------------------

  plt.subplot(3, 2, 6)
  plt.grid(which = 'both')
  multiPlot(
      #[CircleFullResults['time'], FLCFullResults['time'], ChaudhariFullResults['time']],
      #[CircleFullResults['E'], FLCFullResults['E'], ChaudhariFullResults['E']],
      [FLCFullResults['time']],
      [FLCFullResults['E']],
      ['g-'],
      ['GA_FLC controller'],
      ['2'],
      #['m-', 'g-','r--',],
      #['Circle controller', 'GA_FLC controller','Chaudhari-based controller',]
      )
  plt.legend(loc = 'best')
  plt.xlabel('Time(s)')
  plt.ylabel('Energy consumption ( J )')

else:
  multiPlot(
      [pathX, FLCFullResults['x']],
      [pathY, FLCFullResults['y']],
      ['b-', 'r:', ],
      ['Planned path', 'GA_FLC controller'],
      [1,3]
      )
  plt.legend(loc = 'best')
  plt.xlabel('x(m)')
  plt.ylabel('y(m)')

  #--plot the distance--------------------------------------------------------------
  plt.subplot(3, 2, 2)
  plt.grid(which = 'both') 
  multiPlot(
      [FLCFullResults['time']],
      [FLCFullResults['d']],
      ['r:'],
      ['GA_FLC controller'],
      [3]
      )
  plt.legend(loc = 'best')
  plt.xlabel('Time(s)')
  plt.ylabel('Travel distance (m)')

  #---plot the velocity----------------------------------------------------------
  plt.subplot(3, 2, 3)
  plt.grid(which = 'both') 
  multiPlot(
      [FLCFullResults['time']],
      [FLCFullResults['v']],
      ['r:'],
      ['GA_FLC controller'],
      [3]
      )
  plt.legend(loc = 'lower left')
  plt.xlabel('Time(s)')
  plt.ylabel('Linear Velocity (m/s)')

  #--plot the omega-------------------------------------------------------------
  plt.subplot(3, 2, 4)
  plt.grid(which = 'both') 
  multiPlot(
      [FLCFullResults['time']],
      [FLCFullResults['omega']],
      ['r:'],
      ['GA_FLC controller'],
      [3]
      )
  plt.legend(loc = 'lower right')
  plt.xlabel('Time(s)')
  plt.ylabel('Angular velocity (rad/s)')

  #--plot the total energy consumption------------------------------------------
  plt.subplot(3, 2, 5)
  plt.grid(which = 'both') 
  multiPlot(
      [FLCFullResults['time']],
      [FLCFullResults['E']],
      ['r:'],
      ['GA_FLC controller'],
      [3]
      )
  plt.legend(loc = 'lower right')
  plt.xlabel('Time(s)')
  plt.ylabel('Energy consumption ( J )')

"""### Results List"""

import pandas as pd
if Waypoint:
  data = [
      {'Controller Name': 'Circle', 'Energy [J]': CircleFullResults['E'][-1], 'Distance [m]': CircleFullResults['d'][-1]},
      {'Controller Name': 'Robins-Mathew', 'Energy [J]': RobinFullResults['E'][-1], 'Distance [m]': RobinFullResults['d'][-1]},
      {'Controller Name': 'Designed FLC', 'Energy [J]': FuzzyOriginalResults['E'][-1], 'Distance [m]': FuzzyOriginalResults['d'][-1]},
      {'Controller Name': 'Optimized FLC', 'Energy [J]': FLCFullResults['E'][-1], 'Distance [m]': FLCFullResults['d'][-1]},
      {'Controller Name': 'Chaudhari-based controller', 'Energy [J]': ChaudhariFullResults['E'][-1], 'Distance [m]': ChaudhariFullResults['d'][-1]},
      {'Controller Name': 'Thoa-based controller', 'Energy [J]': ThoaFullResults['E'][-1], 'Distance [m]': ThoaFullResults['d'][-1]},
      {'Controller Name': 'Expert-based controller', 'Energy [J]': ExpertFullResults['E'][-1], 'Distance [m]': ExpertFullResults['d'][-1]},
      {'Controller Name': 'Mohammadian-FLC_GA', 'Energy [J]': MohammadianFullResults['E'][-1], 'Distance [m]': MohammadianFullResults['d'][-1]},
  ]
else:
  data = [
      {'Controller Name': 'Optimized FLC', 'Energy [J]': FLCFullResults['E'][-1], 'Distance [m]': FLCFullResults['d'][-1]}]
display(pd.DataFrame(data))

"""### Comparison with Other Optimizations"""

experimentHistory = {
    #'Designed FLC' : _fullFLCChromosome,   
    'Optimization 30 Generations': [ 1.66945319,  1.71315478,  1.73166575,  6.41785765,  0.82326834,  4.19483122,
  6.80002715,  2.66657012,  9.09056893,  8.40993609,  9.97817036,  0.5012167,
  3.05664534, -2.65868572,  3.56420388,  0.04795399, -0.7801222,   0.06109426,
  3.83096185,  2.87048656,  3.54832038,  3.48183375, 25.2023642,  12.38948779,
  4.12048906, 15.35352726, 23.13789911, 14.24417662,  3.79856803, 12.04732624,
 19.26736748, 24.04485383, 27.26133454,  5.95988023, 22.71341036, 11.07041544,
 10.91860759,  6.16753382, 14.68475489,  4.67818727,  3.8179768,  23.80372075,
 24.84867782, 17.21845208],
    'Optimization 50 Generations': [ 5.48480403,  3.45251031,  0.533103,   6.23088519,  8.81192815,  3.0089191,
  2.96449664,  7.57804162,  7.39091206,  5.93997787,  0.39401071,  4.47315433,
  3.64198131, -1.58609149,  2.75363357,  5.35213611, -0.90869068,  0.03411587,
  1.74110187,  1.24724031,  4.19465104,  0.71821741, 21.35582074,  1.90871953,
  3.42259059, 23.17381497,  4.5970014,  14.67073141, 21.46264038, 19.91491024,
 29.08640452,  0.14712622, 21.83371667,  1.05298336, 23.97376335,  0.25197981,
 21.25871058, 10.51462003, 12.69759731,  5.11001624, 16.03934638, 21.44965872,
 17.37358442, 24.46202538],    
    'Optimization 100 Generations': [ 3.58890621e+00,  3.29788515e+00,  1.41272761e+00,  8.56825844e+00,
  8.31424385e-01,  3.66314080e+00,  6.76662543e+00,  8.92524456e+00,
  8.61479399e+00,  4.80731715e+00,  7.97752532e+00,  7.95215844e-02,
  3.06750898e+00, -2.66105402e+00,  3.57541804e+00,  1.25714408e-02,
 -8.00665038e-01,  3.30528416e-02,  3.88436258e+00,  3.08867122e+00,
  3.05045641e+00,  4.40328171e+00,  2.85553541e+01,  1.56066869e+01,
  3.96206528e+00,  1.51371855e+01,  2.38745169e+01,  1.30312845e+01,
  5.13110053e+00,  1.32401692e+01,  2.04413867e+01,  2.41512585e+01,
  5.50268110e+00,  5.80911680e+00,  2.37928753e+01,  1.06873383e+01,
  1.12408747e+01,  5.17504372e+00,  1.30112645e+01,  4.90275290e+00,
  1.08971157e+01,  2.23790120e+01,  2.79745110e+01,  1.40183751e+01],    
    'Optimization 150 Generations': [ 3.66192925e+00,  1.94051028e+00,  1.80589521e+00,  9.35923429e+00,
  6.29348510e-01,  3.67339326e+00,  6.58102805e+00,  8.69394564e+00,
  8.74500807e+00,  5.42952032e+00,  7.27304698e+00,  7.92721407e-02,
  2.58301153e+00, -2.67026278e+00,  3.57545145e+00,  1.25831615e-02,
 -5.91028584e-01,  2.33413749e-02,  3.88436707e+00,  3.13199069e+00,
  3.27227940e+00,  4.41217541e+00,  2.83192070e+01,  1.07340477e+01,
  3.97423515e+00,  1.51381501e+01,  2.26181954e+01,  1.29373175e+01,
  2.22751511e-01,  1.32398324e+01,  2.04415700e+01,  1.09482986e+01,
  5.50185017e+00,  5.80790260e+00,  2.33017995e+01,  1.06873144e+01,
  1.12408747e+01,  3.72839395e+00,  1.22280515e+01,  4.57992211e+00,
  1.08970815e+01,  2.24108497e+01,  2.97264385e+01,  2.55019306e+01],    
    'Optimization 200 Generations': [ 3.67124875e+00,  1.10410556e+00,  1.87733267e+00,  9.58325181e+00,
  2.53733116e+00,  3.38894300e+00,  3.80725896e+00,  8.63259729e+00,
  8.75637290e+00,  7.33995805e+00,  7.24795725e+00,  1.52387688e-02,
  6.08969059e+00, -2.67188966e+00,  3.57545145e+00,  1.16755674e-02,
 -5.96131673e-01,  1.98935658e-02,  3.86391460e+00,  3.13698965e+00,
  3.01054404e+00,  4.43728554e+00,  2.86623698e+01,  1.07336250e+01,
  3.97423515e+00,  1.51395951e+01,  2.06035264e+01,  1.33091875e+01,
  1.41078659e-04,  1.32398779e+01,  2.04415703e+01,  1.09482986e+01,
  5.50099503e+00,  5.80793062e+00,  2.56325715e+01,  1.06872884e+01,
  1.12408747e+01,  3.75566216e-01,  1.20798289e+01,  4.55074728e+00,
  1.08970815e+01,  2.22721497e+01,  2.65501820e+01,  2.04000412e+01]
}

if Waypoint:
  data = [
      {'Controller Name': 'Circle', 'Energy [J]': CircleFullResults['E'][-1], 'Distance [m]': CircleFullResults['d'][-1]},
      {'Controller Name': 'Robins-Mathew', 'Energy [J]': RobinFullResults['E'][-1], 'Distance [m]': RobinFullResults['d'][-1]},
      {'Controller Name': 'Designed FLC', 'Energy [J]': FuzzyOriginalResults['E'][-1], 'Distance [m]': FuzzyOriginalResults['d'][-1]},
      {'Controller Name': 'Optimized FLC', 'Energy [J]': FLCFullResults['E'][-1], 'Distance [m]': FLCFullResults['d'][-1]},
      {'Controller Name': 'Chaudhari-based controller', 'Energy [J]': ChaudhariFullResults['E'][-1], 'Distance [m]': ChaudhariFullResults['d'][-1]},
      {'Controller Name': 'Thoa-based controller', 'Energy [J]': ThoaFullResults['E'][-1], 'Distance [m]': ThoaFullResults['d'][-1]},
      {'Controller Name': 'Expert-based controller', 'Energy [J]': ExpertFullResults['E'][-1], 'Distance [m]': ExpertFullResults['d'][-1]},
      {'Controller Name': 'Mohammadian-FLC_GA', 'Energy [J]': MohammadianFullResults['E'][-1], 'Distance [m]': MohammadianFullResults['d'][-1]},    
  ]
else:
  data = [
      {'Controller Name': 'Optimized FLC', 'Energy [J]': FLCFullResults['E'][-1], 'Distance [m]': FLCFullResults['d'][-1]}]

for key, value in experimentHistory.items():
    currentDescription = fromChromozomeToDescriptionFuzzy(value, simulationDescription)
    fullResults = runSimulation(currentDescription, createFuzzyController, selectors=selectors)
    dataRow = {'Controller Name': key, 'Energy [J]': fullResults['E'][-1], 'Distance [m]': fullResults['d'][-1]}
    data.append(dataRow)
    
print(data)    
display(pd.DataFrame(data))

Best_Chromosome = [ 3.67124875e+00,  1.10410556e+00,  1.87733267e+00,  9.58325181e+00,
  2.53733116e+00,  3.38894300e+00,  3.80725896e+00,  8.63259729e+00,
  8.75637290e+00,  7.33995805e+00,  7.24795725e+00,  1.52387688e-02,
  6.08969059e+00, -2.67188966e+00,  3.57545145e+00,  1.16755674e-02,
 -5.96131673e-01,  1.98935658e-02,  3.86391460e+00,  3.13698965e+00,
  3.01054404e+00,  4.43728554e+00,  2.86623698e+01,  1.07336250e+01,
  3.97423515e+00,  1.51395951e+01,  2.06035264e+01,  1.33091875e+01,
  1.41078659e-04,  1.32398779e+01,  2.04415703e+01,  1.09482986e+01,
  5.50099503e+00,  5.80793062e+00,  2.56325715e+01,  1.06872884e+01,
  1.12408747e+01,  3.75566216e-01,  1.20798289e+01,  4.55074728e+00,
  1.08970815e+01,  2.22721497e+01,  2.65501820e+01,  2.04000412e+01]

"""### Visualisation of Membership functions"""

Chromosome = Best_Chromosome
fuzzySimDescription = fromChromozomeToDescriptionFuzzy(Chromosome, simulationDescription)
print(fuzzySimDescription)

plt.rcParams["figure.figsize"] = (20, 5)
plt.rcParams["font.size"] = "18"

def plotMemberFunction(S, M):
    for key, value in M.items():
        data = fuzz.trimf(np.array(S), value)
        plt.plot(S, data, label=key)        
    pass

def plotMemberFunctionsAll(description):
    distanceDesc = description['controllerParams']['fuzzyDescription']['inputs']['distance']
    plotMemberFunction(
        distanceDesc['S'],
        distanceDesc['M'])       
    plt.show()
    
    angleDesc = description['controllerParams']['fuzzyDescription']['inputs']['angle']
    plotMemberFunction(
        angleDesc['S'],
        angleDesc['M'])
    plt.show()
    
    omegaRDesc = description['controllerParams']['fuzzyDescription']['outputs']['omegaR']
    plotMemberFunction(
        omegaRDesc['S'],
        omegaRDesc['M'])
    plt.show()
    
    omegaLDesc = description['controllerParams']['fuzzyDescription']['outputs']['omegaL']
    plotMemberFunction(
        omegaLDesc['S'],
        omegaLDesc['M'])
    plt.show()
    
plotMemberFunctionsAll(FuzzyOriginalSimDescription)
plotMemberFunctionsAll(FLCSimDescription)

"""# Fuzzy Control System

Inspired by https://pythonhosted.org/scikit-fuzzy/auto_examples/plot_control_system_advanced.html#example-plot-control-system-advanced-py
"""

fuzzyDescription = {
        'inputs': {
            'distance' : {
                'S': list(np.arange(0, 10, 0.1)),
                'M': {'VC': [0, 0, 2.5], 'C': [0, 2.5, 5], 'M': [2.5, 5, 7.5], 'F': [5, 7.5, 10], 'VF': [7.5, 10, 10]}
            },
            'angle' : {
                'S': list(np.arange(-3.14, 3.14, 0.0628)),
                'M': {'BN': [-3.14, -3.14, -1.57], 'N': [-3.14, -1.57, 0], 'Z': [-1.57, 0, 1.57], 'P': [0, 1.57, 3.14], 'BP': [1.57, 3.14, 3.14]}
            }
        },
        'outputs': {
            'omegaR': {
                'S': list(np.arange(0, 30, 0.3)),
                'rules': {
                    'VC': {'BN': 'VSR', 'N': 'SR', 'Z': 'VSR', 'P': 'BR', 'BP': 'VBR'},
                    'C': {'BN': 'VSR', 'N': 'SR', 'Z': 'SR', 'P': 'BR', 'BP': 'VBR'},
                    'M': {'BN': 'VSR', 'N': 'SR', 'Z': 'MBR', 'P': 'BR', 'BP': 'VBR'},
                    'F': {'BN': 'VSR', 'N': 'SR', 'Z': 'BR', 'P': 'BR', 'BP': 'VBR'},
                    'VF': {'BN': 'VSR', 'N': 'SR', 'Z': 'VBR', 'P': 'BR', 'BP': 'VBR'}
                },
                'mode': 'centroid',
                'M': {'VSR': [0, 0, 7.5], 'SR': [0, 7.5, 15], 'MBR': [7.5, 15, 22.5], 'BR': [15, 22.5, 30], 'VBR': [22.5, 30, 30]}
            },
            'omegaL': {
                'S': list(np.arange(0, 30, 0.3)),
                'rules': {
                    'VC': {'BN': 'VBL', 'N': 'BL', 'Z': 'VSL', 'P': 'SL', 'BP': 'VSL'},
                    'C': {'BN': 'VBL', 'N': 'BL', 'Z': 'SL', 'P': 'SL', 'BP': 'VSL'},
                    'M': {'BN': 'VBL', 'N': 'BL', 'Z': 'MBL', 'P': 'SL', 'BP': 'VSL'},
                    'F': {'BN': 'VBL', 'N': 'BL', 'Z': 'BL', 'P': 'SL', 'BP': 'VSL'},
                    'VF': {'BN': 'VBL', 'N': 'BL', 'Z': 'VBL', 'P': 'SL', 'BP': 'VSL'} 
                },
                'mode': 'centroid',
                'M': {'VSL': [0, 0, 7.5], 'SL': [0, 7.5, 15], 'MBL': [7.5, 15, 22.5], 'BL': [15, 22.5, 30], 'VBL': [22.5, 30, 30]}
            }
        }
    }

import numpy as np
import skfuzzy.control as ctrl
import skfuzzy as fuzz

# Sparse universe makes calculations faster, without sacrifice accuracy.
# Only the critical points are included here; making it higher resolution is
# unnecessary.
universeDistance = np.array(fuzzyDescription['inputs']['distance']['S'])
universeAngle = np.array(fuzzyDescription['inputs']['angle']['S'])
universeOmega = np.array(fuzzyDescription['outputs']['omegaR']['S'])
# Create the three fuzzy variables - two inputs, one output
distanceVar = ctrl.Antecedent(universeDistance, 'distance')
angleVar = ctrl.Antecedent(universeAngle, 'angle')
omegaVar = ctrl.Consequent(universeOmega, 'omega')

# Here we use the convenience `automf` to populate the fuzzy variables with
# terms. The optional kwarg `names=` lets us specify the names of our Terms.

for key, value in fuzzyDescription['inputs']['distance']['M'].items():
    distanceVar[key] = fuzz.trimf(universeDistance, value)
    
for key, value in fuzzyDescription['inputs']['angle']['M'].items():
    angleVar[key] = fuzz.trimf(universeAngle, value)
    
for key, value in fuzzyDescription['outputs']['omegaR']['M'].items():
    omegaVar[key] = fuzz.trimf(universeOmega, value)

rule0 = ctrl.Rule(antecedent=(angleVar['BN'] |
                              (angleVar['Z'] & distanceVar['VC'])),
                  consequent=omegaVar['VSR'], label='rule 0')
rule1 = ctrl.Rule(antecedent=(angleVar['N'] |
                              (angleVar['Z'] & distanceVar['C'])),
                  consequent=omegaVar['SR'], label='rule 1')                  
rule2 = ctrl.Rule(antecedent=(angleVar['Z'] & distanceVar['M']),
                  consequent=omegaVar['MBR'], label='rule 2')
rule3 = ctrl.Rule(antecedent=(angleVar['P'] |
                              (angleVar['Z'] & distanceVar['F'])),
                  consequent=omegaVar['BR'], label='rule 3')
rule4 = ctrl.Rule(antecedent=(angleVar['BP'] |
                              (angleVar['Z'] & distanceVar['VF'])),
                  consequent=omegaVar['VBR'], label='rule 4')
                  
system = ctrl.ControlSystem(rules=[rule0, rule1, rule2, rule3, rule4])

inputsDistance = fuzzyDescription['inputs']['distance']['M']
inputsSpaceDistance = np.array(fuzzyDescription['inputs']['distance']['S'])

inputsAngle = fuzzyDescription['inputs']['angle']['M']
inputsSpaceAngle = np.array(fuzzyDescription['inputs']['angle']['S'])

outputsOmegaR = fuzzyDescription['outputs']['omegaR']['M']
outputSpaceOmegaR = np.array(fuzzyDescription['outputs']['omegaR']['S'])
outputRulesOmegaR = fuzzyDescription['outputs']['omegaR']['rules']

outputsOmegaL = fuzzyDescription['outputs']['omegaL']['M']
outputSpaceOmegaL = np.array(fuzzyDescription['outputs']['omegaL']['S'])
outputRulesOmegaL = fuzzyDescription['outputs']['omegaL']['rules']


inputsDistanceFuzzyfier = createFuzzyfier(inputsSpaceDistance, inputsDistance)
inputsAngleFuzzyfier = createFuzzyfier(inputsSpaceAngle, inputsAngle)

inferenceSystem_R = createInferenceSystem(inputsDistanceFuzzyfier, inputsAngleFuzzyfier, outputSpaceOmegaR, outputsOmegaR, outputRulesOmegaR)
outputDefuzzyfier_R = createDefuzzyfier(outputSpaceOmegaL, mode='centroid')

inferenceSystem_L = createInferenceSystem(inputsDistanceFuzzyfier, inputsAngleFuzzyfier, outputSpaceOmegaL, outputsOmegaL, outputRulesOmegaL)
outputDefuzzyfier_L = createDefuzzyfier(outputSpaceOmegaL, mode='centroid')

fullSystem_R = createFullFuzzySystem(inferenceSystem_R, outputDefuzzyfier_R)

# Plot the result in pretty 3D with alpha blending
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D  # Required for 3D plotting

def fuzzyPlot(x, y, z):
    fig = plt.figure(figsize=(8, 8))
    ax = fig.add_subplot(111, projection='3d')

    surf = ax.plot_surface(x, y, z, rstride=1, cstride=1, cmap='viridis',
                           linewidth=0.4, antialiased=True)

    #cset = ax.contourf(x, y, z, zdir='z', offset=-2.5, cmap='viridis', alpha=0.5)
    #cset = ax.contourf(x, y, z, zdir='x', offset=3, cmap='viridis', alpha=0.5)
    #cset = ax.contourf(x, y, z, zdir='y', offset=3, cmap='viridis', alpha=0.5)

    ax.view_init(30, 200)

sim = ctrl.ControlSystemSimulation(system)


x, y = np.meshgrid(universeAngle, universeDistance)
zA = np.zeros_like(x)
zB = np.zeros_like(x)
zC = np.zeros_like(x)

for i, angle in enumerate(universeAngle):
    for j, distance in enumerate(universeDistance):
        sim.input['angle'] = angle
        sim.input['distance'] = distance
        #sim.compute()
        #resultA = sim.output['omega']
        resultB = fullSystem_R(distance, angle)
        zB[j, i] = resultB
        #zA[i, j] = resultA
        #zC[i, j] = resultA - resultB
        #print(abs(resultA - resultB), ', ', end='')
    
    
#fuzzyPlot(x, y, zA)    
fuzzyPlot(x, y, zB)    
#fuzzyPlot(x, y, zC)

# Commented out IPython magic to ensure Python compatibility.
# %%timeit 
# resultB = fullSystem_R(distance, angle)

# Commented out IPython magic to ensure Python compatibility.
# '''
# %%timeit 
# sim.input['angle'] = angle
# sim.input['distance'] = distance
# sim.compute()
# resultA = sim.output['omega']
# '''